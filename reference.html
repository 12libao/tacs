
<!DOCTYPE html>

<html lang="python">
  <head>
    <meta charset="utf-8" />
    <title>Class reference &#8212; TACS  documentation</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/custom.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Example: CRM Optimization" href="Example-CRM_Optimization.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Example-CRM_Optimization.html" title="Example: CRM Optimization"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">TACS  documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="Example-CRM_Optimization.html"
                        title="previous chapter">Example: CRM Optimization</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/reference.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-tacs">
<span id="class-reference"></span><h1>Class reference<a class="headerlink" href="#module-tacs" title="Permalink to this headline">¶</a></h1>
<p>TACS is a parallel finite-element package for analysis and
gradient-based design optimization.</p>
<dl class="py function">
<dt id="tacs.get_cython_include">
<code class="sig-prename descclassname">tacs.</code><code class="sig-name descname">get_cython_include</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tacs.html#get_cython_include"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tacs.get_cython_include" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the include directory for the Cython .pxd files in TACS</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.get_include">
<code class="sig-prename descclassname">tacs.</code><code class="sig-name descname">get_include</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tacs.html#get_include"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tacs.get_include" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the include directory for the Cython .pxd files in TACS</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.get_libraries">
<code class="sig-prename descclassname">tacs.</code><code class="sig-name descname">get_libraries</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tacs.html#get_libraries"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tacs.get_libraries" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the library directories</p>
</dd></dl>

<span class="target" id="module-tacs.TACS.Assembler"></span><dl class="py function">
<dt id="tacs.TACS.Assembler.addAdjointResProducts">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">addAdjointResProducts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.addAdjointResProducts" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is collective on all TACSAssembler processes. This
computes the product of the derivative of the residual
w.r.t. the design variables with several adjoint vectors
simultaneously. This saves computational time as the derivative
of the element residuals can be reused for each adjoint
vector. This function performs the same task as
evalAdjointResProduct, but uses more memory than calling it for
each adjoint vector.</p>
<p>adjoint: the array of adjoint vectors
dvSens: the product of the derivative of the residuals and the adjoint
num_dvs: the number of design variables</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.addAdjointResXptSensProducts">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">addAdjointResXptSensProducts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.addAdjointResXptSensProducts" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is collective on all TACSAssembler processes. This
computes the product of the derivative of the residual
w.r.t. the node locations with several adjoint vectors
simultaneously.</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.addDVSens">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">addDVSens</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.addDVSens" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the derivative of a list of functions w.r.t. the design
variables.</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.addJacobianVecProduct">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">addJacobianVecProduct</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.addJacobianVecProduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Jacobian-vector product</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.addMatDVSensInnerProduct">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">addMatDVSensInnerProduct</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.addMatDVSensInnerProduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the derivative of the inner product of the specified
matrix with the input vectors to the design variable
sensitivity vector A.</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.addSVSens">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">addSVSens</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.addSVSens" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the derivative of the function w.r.t. the state
variables.</p>
<p>function: the function pointer</p>
<p>vec:        the derivative of the function w.r.t. the state variables</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.addXptSens">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">addXptSens</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.addXptSens" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the derivative of a list of functions w.r.t.
the node locations</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.applyBCs">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">applyBCs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.applyBCs" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply boundary conditions to the vector</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.applyMatBCs">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">applyMatBCs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.applyMatBCs" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply boundary conditions to the matrix</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.assembleJacobian">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">assembleJacobian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.assembleJacobian" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble the Jacobian matrix</p>
<p>This function assembles the global Jacobian matrix and
residual. This Jacobian includes the contributions from all
elements. The Dirichlet boundary conditions are applied to the
matrix by zeroing the rows of the matrix associated with a
boundary condition, and setting the diagonal to unity. The
matrix assembly also performs any communication required so that
the matrix can be used immediately after assembly.</p>
<p>alpha:      coefficient on the variables
beta:        coefficient on the time-derivative terms
gamma:      coefficient on the second time derivative term
residual:  the residual of the governing equations
A:            the Jacobian matrix
matOr:      the matrix orientation NORMAL or TRANSPOSE</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.assembleMatCombo">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">assembleMatCombo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.assembleMatCombo" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble a combination of two matrices</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.assembleMatType">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">assembleMatType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.assembleMatType" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble the Jacobian matrix</p>
<p>This function assembles the global Jacobian matrix and
residual. This Jacobian includes the contributions from all
elements. The Dirichlet boundary conditions are applied to the
matrix by zeroing the rows of the matrix associated with a
boundary condition, and setting the diagonal to unity. The
matrix assembly also performs any communication required so that
the matrix can be used immediately after assembly.</p>
<p>residual:  the residual of the governing equations
A:            the Jacobian matrix
alpha:      coefficient on the variables
beta:        coefficient on the time-derivative terms
gamma:      coefficient on the second time derivative
term
matOr:      the matrix orientation NORMAL or TRANSPOSE</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.assembleRes">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">assembleRes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.assembleRes" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble the residual associated with the input load case.</p>
<p>This residual includes the contributions from element tractions
set in the TACSSurfaceTraction class and any point loads. Note
that the vector entries are zeroed first, and that the Dirichlet
boundary conditions are applied after the assembly of the
residual is complete.</p>
<p>rhs:        the residual output</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.computeReordering">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">computeReordering</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.computeReordering" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a reordering of the unknowns before initialize()</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.copyVariables">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">copyVariables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.copyVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the values of the state variables</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.createDesignVec">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">createDesignVec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.createDesignVec" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a distribute design variable vector</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.createMat">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">createMat</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.createMat" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a distributed matrix</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.createNodeVec">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">createNodeVec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.createNodeVec" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a distributed node vector</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.createSchurMat">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">createSchurMat</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.createSchurMat" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a parallel matrix specially suited for finite-element
analysis.</p>
<p>On the first call, this computes a reordering with the scheme
provided. On subsequent calls, the reordering scheme is reused s
that all FEMats, created from the same TACSAssembler object have
the same non-zero structure.  This makes adding matrices
together easier (which is required for eigenvalue computations.)</p>
<p>The first step is to determine the coupling nodes. (For a serial
case there are no coupling nodes, so this is very simple!)
Then, the nodes that are not coupled to other processes are
determined. The coupling and non-coupling nodes are ordered
separately.  The coupling nodes must be ordered at the end of
the block, while the local nodes must be ordered first. This
type of constraint is not usually imposed in matrix ordering
routines, so here we use a kludge.  First, order all the nodes
and determine the ordering of the coupling variables within the
full set.  Next, order the local nodes. Tis hopefully reduces
the fill-ins required, although there is no firm proof to back
that up.</p>
<p>The results from the reordering are placed in a set of
objects. The matrix reordering is stored in feMatBIndices and
feMatCIndices while two mapping objects are created that map the
variables from the global vector to reordered matrix.</p>
<p>Mathematically this reordering can be written as follows,</p>
<p>A1 = (P A P^{T})</p>
<p>where P^{T} is a permutation of the columns (variables), while P
is a permutation of the rows (equations).</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.createVec">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">createVec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.createVec" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a distributed vector.</p>
<p>Vector classes initialized by one TACS object, cannot be
used by a second, unless they share are exactly the
parallel layout.</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.evalEnergies">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">evalEnergies</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.evalEnergies" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the kinetic and potential energies</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.evalFunctions">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">evalFunctions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.evalFunctions" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a list of TACS function</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.getDesignVarRange">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">getDesignVarRange</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.getDesignVarRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the design variable range.</p>
<p>This call is collective on all TACS processes. The ranges
provided by indivdual objects may not be consistent (if
someone provided incorrect data they could be.) Make a
best guess; take the minimum upper bound and the maximum
lower bound.</p>
<p>lowerBound: the lower bound on the design variables (output)
upperBound: the upper bound on the design variables (output)
numDVs:      the number of design variables</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.getDesignVars">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">getDesignVars</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.getDesignVars" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect all the design variable values assigned by this
process</p>
<p>This code does not ensure consistency of the design variable
values between processes. If the values of the design
variables are inconsistent to begin with, the maximum
design variable value is returned. Call setDesignVars to
make them consistent.</p>
<p>Each process contains objects that maintain their own design
variable values. Ensuring the consistency of the ordering is
up to the user. Having multiply-defined design variable
numbers corresponding to different design variables
results in undefined behaviour.</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.getElementData">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">getElementData</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.getElementData" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the element data associated with the element</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.getElementNodes">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">getElementNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.getElementNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the node numbers associated with the given element</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.getElements">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">getElements</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.getElements" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the elements</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.getInitConditions">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">getInitConditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.getInitConditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the initial conditions</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.getMPIComm">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">getMPIComm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.getMPIComm" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the MPI communicator</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.getNodes">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">getNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.getNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the node locations</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.getNumDependentNodes">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">getNumDependentNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.getNumDependentNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of dependent nodes</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.getNumElements">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">getNumElements</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.getNumElements" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of elements</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.getNumNodes">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">getNumNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.getNumNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of nodes in the TACSAssembler</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.getNumOwnedNodes">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">getNumOwnedNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.getNumOwnedNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of owned nodes</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.getOwnerRange">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">getOwnerRange</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.getOwnerRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the ranges of global node numbers owned by each processor</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.getReordering">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">getReordering</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.getReordering" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the reordering</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.getSimulationTime">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">getSimulationTime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.getSimulationTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the simulation time from TACS</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.getVariables">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">getVariables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.getVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the values of the state variables</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.getVarsPerNode">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">getVarsPerNode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.getVarsPerNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of variables per node</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.initialize">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">initialize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to call after all the nodes and elements have been
added into the created instance of TACS. This function need not
be called when tacs is created using TACSCreator class.</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.reorderVec">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">reorderVec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.reorderVec" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorder the vector based on the TACSAssembler reordering</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.setAuxElements">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">setAuxElements</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.setAuxElements" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the auxiliary elements</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.setBCs">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">setBCs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.setBCs" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the Dirichlet boundary conditions to the state vector</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.setDependentNodes">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">setDependentNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.setDependentNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the dependent node connectivity</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.setDesignVars">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">setDesignVars</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.setDesignVars" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the design variables.</p>
<p>The design variable values provided must be the same on all
processes for consistency. This call however, is not
collective.</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.setElementConnectivity">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">setElementConnectivity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.setElementConnectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the connectivity</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.setElements">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">setElements</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.setElements" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the elements in to TACSAssembler</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.setNodes">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">setNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.setNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the node locations</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.setNumThreads">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">setNumThreads</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.setNumThreads" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the number of threads to use in computation</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.setSimulationTime">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">setSimulationTime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.setSimulationTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the simulation time within TACS</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.setVariables">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">setVariables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.setVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the values of the state variables</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.testElement">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">testElement</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.testElement" title="Permalink to this definition">¶</a></dt>
<dd><p>Test the implementation of the given element number.</p>
<p>This tests the stiffness matrix and various parts of the
design-sensitivities: the derivative of the determinant of the
Jacobian, the derivative of the strain w.r.t. the nodal
coordinates, and the state variables and the derivative of the
residual w.r.t. the design variables and nodal coordinates.</p>
<p>elemNum:      the element number to test
print_level:  the print level to use</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.testFunction">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">testFunction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.testFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Test the implementation of the function.</p>
<p>This tests the state variable sensitivities and the design
variable sensitivities of the function of interest. These
sensitivities are computed based on a random perturbation of
the input values.  Note that a system of equations should be
solved - or the variables should be set randomly before
calling this function, otherwise this function may produce
unrealistic function values.</p>
<p>Note that this function uses a central difference if the
real code is compiled, and a complex step approximation if
the complex version of the code is used.</p>
<p>func:    the function to test
num_dvs: the number of design variables to use
dh:      the step size to use</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.zeroDDotVariables">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">zeroDDotVariables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.zeroDDotVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero the values of the 2nd time-derivatives of the state
variables</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.zeroDotVariables">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">zeroDotVariables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.zeroDotVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero the values of the time-derivatives of the state variables</p>
</dd></dl>

<dl class="py function">
<dt id="tacs.TACS.Assembler.zeroVariables">
<code class="sig-prename descclassname">tacs.TACS.Assembler.</code><code class="sig-name descname">zeroVariables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tacs.TACS.Assembler.zeroVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero the entries of the local variables</p>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv413TACSAssembler">
<span id="_CPPv313TACSAssembler"></span><span id="_CPPv213TACSAssembler"></span><span id="TACSAssembler"></span><span class="target" id="class_t_a_c_s_assembler"></span><em class="property">class </em><code class="sig-name descname">TACSAssembler</code> : <em class="property">public</em> TACSObject<a class="headerlink" href="#_CPPv413TACSAssembler" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler13TACSAssemblerE8MPI_Commiiii">
<span id="_CPPv3N13TACSAssembler13TACSAssemblerE8MPI_Commiiii"></span><span id="_CPPv2N13TACSAssembler13TACSAssemblerE8MPI_Commiiii"></span><span id="TACSAssembler::TACSAssembler__MPI_Comm.i.i.i.i"></span><span class="target" id="class_t_a_c_s_assembler_1a12b120550d760160a6fe9b8c72cc7b8c"></span><code class="sig-name descname">TACSAssembler</code><span class="sig-paren">(</span>MPI_Comm <em>_tacs_comm</em>, int <em>_varsPerNode</em>, int <em>_numOwnedNodes</em>, int <em>_numElements</em>, int <em>_numDependentNodes</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler13TACSAssemblerE8MPI_Commiiii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor for the <a class="reference internal" href="#class_t_a_c_s_assembler"><span class="std std-ref">TACSAssembler</span></a> object</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tacs_comm</span></code>: the TACS communicator </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">varsPerNode</span></code>: the number of degrees of freedom per node </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numOwnedNodes</span></code>: the number of locally-owned nodes </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numElements</span></code>: the number of elements in the mesh </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numDependentNodes</span></code>: the number of dependent nodes in the mesh </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssemblerD0Ev">
<span id="_CPPv3N13TACSAssemblerD0Ev"></span><span id="_CPPv2N13TACSAssemblerD0Ev"></span><span id="TACSAssembler::~TACSAssembler"></span><span class="target" id="class_t_a_c_s_assembler_1adb2e826081d582439f78dc4f4a4b8ced"></span><code class="sig-name descname">~TACSAssembler</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssemblerD0Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clean up the allocated memory and decref() all objects </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler22setElementConnectivityEPKiPKi">
<span id="_CPPv3N13TACSAssembler22setElementConnectivityEPKiPKi"></span><span id="_CPPv2N13TACSAssembler22setElementConnectivityEPKiPKi"></span><span id="TACSAssembler::setElementConnectivity__iCP.iCP"></span><span class="target" id="class_t_a_c_s_assembler_1aa1e397a86750859f1013d25c551df721"></span>int <code class="sig-name descname">setElementConnectivity</code><span class="sig-paren">(</span><em class="property">const</em> int *<em>ptr</em>, <em class="property">const</em> int *<em>conn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler22setElementConnectivityEPKiPKi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the element connectivity.</p>
<p>Note that the number of elements that are set at this stage must be consistent with the number of elements passed in when <a class="reference internal" href="#class_t_a_c_s_assembler"><span class="std std-ref">TACSAssembler</span></a> is created. (The connectivity arrays are copied and should be freed by the caller.)</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Fail flag indicating if a failure occured </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ptr</span></code>: Offset into the connectivity array for this processor </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conn</span></code>: The connectivity from elements to global node index </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler22getElementConnectivityEPPKiPPKi">
<span id="_CPPv3N13TACSAssembler22getElementConnectivityEPPKiPPKi"></span><span id="_CPPv2N13TACSAssembler22getElementConnectivityEPPKiPPKi"></span><span id="TACSAssembler::getElementConnectivity__iCPP.iCPP"></span><span class="target" id="class_t_a_c_s_assembler_1af787770da9f095a8f9690cafa73bf38d"></span>void <code class="sig-name descname">getElementConnectivity</code><span class="sig-paren">(</span><em class="property">const</em> int **<em>ptr</em>, <em class="property">const</em> int **<em>conn</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler22getElementConnectivityEPPKiPPKi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the element connectivity.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ptr</span></code>: Offset into the connectivity array for this processor </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conn</span></code>: The connectivity from elements to global node index </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler11setElementsEPP11TACSElement">
<span id="_CPPv3N13TACSAssembler11setElementsEPP11TACSElement"></span><span id="_CPPv2N13TACSAssembler11setElementsEPP11TACSElement"></span><span id="TACSAssembler::setElements__TACSElementPP"></span><span class="target" id="class_t_a_c_s_assembler_1ab6bce6911a6ae2211fbeab40339611a0"></span>int <code class="sig-name descname">setElements</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv411TACSElement" title="TACSElement">TACSElement</a> **<em>_elements</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler11setElementsEPP11TACSElement" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the element array within TACS.</p>
<p>The number of element pointers provided should be equal to the number of elements specified in the <a class="reference internal" href="#class_t_a_c_s_assembler"><span class="std std-ref">TACSAssembler</span></a> constructor. Note that the elements themselves are not copied, just the pointers to them.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Fail flag indicating if a failure occured </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elements</span></code>: The array of element pointers with length = numElements. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler17setDependentNodesEPKiPKiPKd">
<span id="_CPPv3N13TACSAssembler17setDependentNodesEPKiPKiPKd"></span><span id="_CPPv2N13TACSAssembler17setDependentNodesEPKiPKiPKd"></span><span id="TACSAssembler::setDependentNodes__iCP.iCP.doubleCP"></span><span class="target" id="class_t_a_c_s_assembler_1ae74770f6928f42b4c4f785e50c2804aa"></span>int <code class="sig-name descname">setDependentNodes</code><span class="sig-paren">(</span><em class="property">const</em> int *<em>_depNodeIndex</em>, <em class="property">const</em> int *<em>_depNodeToTacs</em>, <em class="property">const</em> double *<em>_depNodeWeights</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler17setDependentNodesEPKiPKiPKd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the dependent node data structure</p>
<p>The dependent nodes are designated by a negative index with a 1-base numbering scheme. This dependent node data structure is a sparse matrix with constant weights that designates the weights applied to the global independent nodes (storred in depNodeToTacs).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Fail flag indicating if a failure occured </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">depNodePtr</span></code>: Offset into the connectivity/weight arrays </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">depNodeToTacs</span></code>: The independent global nodes </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">depNodeWeights</span></code>: The weight applied to each independent node </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler16setDesignNodeMapEiP11TACSNodeMap">
<span id="_CPPv3N13TACSAssembler16setDesignNodeMapEiP11TACSNodeMap"></span><span id="_CPPv2N13TACSAssembler16setDesignNodeMapEiP11TACSNodeMap"></span><span id="TACSAssembler::setDesignNodeMap__i.TACSNodeMapP"></span><span class="target" id="class_t_a_c_s_assembler_1a901666f15bb15830a571c6882e4df7be"></span>void <code class="sig-name descname">setDesignNodeMap</code><span class="sig-paren">(</span>int <em>_designVarsPerNode</em>, TACSNodeMap *<em>_designVarMap</em> = NULL<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler16setDesignNodeMapEiP11TACSNodeMap" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the design variable mapping, indicating the owners of the design vars</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">designVarsPerNode</span></code>: The number of design variables for each var number </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">designVarMap</span></code>: The design variable mapping </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler23setDesignDependentNodesEiPKiPKiPKd">
<span id="_CPPv3N13TACSAssembler23setDesignDependentNodesEiPKiPKiPKd"></span><span id="_CPPv2N13TACSAssembler23setDesignDependentNodesEiPKiPKiPKd"></span><span id="TACSAssembler::setDesignDependentNodes__i.iCP.iCP.doubleCP"></span><span class="target" id="class_t_a_c_s_assembler_1adf996c908f5a7c787b3dd5828d98d1c1"></span>int <code class="sig-name descname">setDesignDependentNodes</code><span class="sig-paren">(</span>int <em>numDepDesignVars</em>, <em class="property">const</em> int *<em>_depNodePtr</em>, <em class="property">const</em> int *<em>_depNodes</em>, <em class="property">const</em> double *<em>_depNodeWeights</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler23setDesignDependentNodesEiPKiPKiPKd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the dependent design variable information</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Error code indicating failure or success </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">numDepDesignVars</span></code>: The number of dependent design variables </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">depNodePtr</span></code>: Pointer into the depNodes array </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">depNodes</span></code>: The dependent node numbers </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">depNodeWeights</span></code>: The weights applied to each independent node </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler6addBCsEiPKiiPKiPK10TacsScalar">
<span id="_CPPv3N13TACSAssembler6addBCsEiPKiiPKiPK10TacsScalar"></span><span id="_CPPv2N13TACSAssembler6addBCsEiPKiiPKiPK10TacsScalar"></span><span id="TACSAssembler::addBCs__i.iCP.i.iCP.TacsScalarCP"></span><span class="target" id="class_t_a_c_s_assembler_1a0c5186669bbcfcc16815665bc59c0c8b"></span>void <code class="sig-name descname">addBCs</code><span class="sig-paren">(</span>int <em>nnodes</em>, <em class="property">const</em> int *<em>nodes</em>, int <em>nbcs</em> = -1, <em class="property">const</em> int *<em>vars</em> = NULL, <em class="property">const</em> TacsScalar *<em>vals</em> = NULL<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler6addBCsEiPKiiPKiPK10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add Dirichlet boundary conditions.</p>
<p>These BCs are added to an object that will be associated with the vectors/matrices that are created using <a class="reference internal" href="#class_t_a_c_s_assembler"><span class="std std-ref">TACSAssembler</span></a>.</p>
<p>Fully-fixed boundary conditions can be specified by passing in nbcs &lt; 0. If the vals array is NULL, then it is assumed that all values are fixed to zero.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nnodes</span></code>: The number of nodes </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nodes</span></code>: The node numbers </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nbcs</span></code>: The number of nodal variables to be constrained </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vars</span></code>: The variable indices satisfying (0 &lt;= vars[i] &lt; varsPerNode) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vals</span></code>: The boundary condition values </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler10addInitBCsEiPKiiPKiPK10TacsScalar">
<span id="_CPPv3N13TACSAssembler10addInitBCsEiPKiiPKiPK10TacsScalar"></span><span id="_CPPv2N13TACSAssembler10addInitBCsEiPKiiPKiPK10TacsScalar"></span><span id="TACSAssembler::addInitBCs__i.iCP.i.iCP.TacsScalarCP"></span><span class="target" id="class_t_a_c_s_assembler_1a141137f2be33191bd836d934093a9716"></span>void <code class="sig-name descname">addInitBCs</code><span class="sig-paren">(</span>int <em>nnodes</em>, <em class="property">const</em> int *<em>nodes</em>, int <em>nbcs</em> = -1, <em class="property">const</em> int *<em>vars</em> = NULL, <em class="property">const</em> TacsScalar *<em>vals</em> = NULL<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler10addInitBCsEiPKiiPKiPK10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add Dirichlet boundary conditions for the initial conditions.</p>
<p>These BCs are added to an object that will be associated with the vectors/matrices that are created using <a class="reference internal" href="#class_t_a_c_s_assembler"><span class="std std-ref">TACSAssembler</span></a>.</p>
<p>Fully-fixed boundary conditions can be specified by passing in nbcs &lt; 0. If the vals array is NULL, then it is assumed that all values are fixed to zero.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nnodes</span></code>: The number of nodes </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nodes</span></code>: The node numbers </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nbcs</span></code>: The number of nodal variables to be constrained </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vars</span></code>: The variable indices satisfying (0 &lt;= vars[i] &lt; varsPerNode) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vals</span></code>: The boundary condition values </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler17computeReorderingE12OrderingType18MatrixOrderingType">
<span id="_CPPv3N13TACSAssembler17computeReorderingE12OrderingType18MatrixOrderingType"></span><span id="_CPPv2N13TACSAssembler17computeReorderingE12OrderingType18MatrixOrderingType"></span><span id="TACSAssembler::computeReordering__OrderingType.MatrixOrderingType"></span><span class="target" id="class_t_a_c_s_assembler_1aa48903b297d94836bebbad1b9c10cd74"></span>void <code class="sig-name descname">computeReordering</code><span class="sig-paren">(</span>OrderingType <em>order_type</em>, MatrixOrderingType <em>mat_type</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler17computeReorderingE12OrderingType18MatrixOrderingType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute a reordering of the nodes.</p>
<p>This function should be called after the element connectivity, boundary conditions and optionally the dependent nodes are set, but before the call to <a class="reference internal" href="#class_t_a_c_s_assembler_1a25714da663c6930e11eb01a307eb5d53"><span class="std std-ref">initialize()</span></a>.</p>
<p>This code computes and stores a reordering based on both the matrix type and the ordering type. The matrix type determines what constitutes a coupling node and what does not. The matrix type only impacts the ordering in parallel computations.</p>
<p>The algorithm proceeds as follows:</p>
<p><ol class="arabic simple">
<li><p>Compute the coupling nodes referenced by another processor</p></li>
<li><p>Order the locally owned nodes based on the input ordering.</p></li>
<li><p>Based on the recvied coupling nodes, set the outgoing node numbers back into the recieving array.</p></li>
<li><p>Set the new values of the nodes on the requesting processes</p></li>
</ol>
</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">order_type</span></code>: The type of ordering to apply </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mat_type</span></code>: The anticipated matrix distribution type </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler11isReorderedEv">
<span id="_CPPv3N13TACSAssembler11isReorderedEv"></span><span id="_CPPv2N13TACSAssembler11isReorderedEv"></span><span id="TACSAssembler::isReordered"></span><span class="target" id="class_t_a_c_s_assembler_1a1b748bbef2ad62a87c8eba3341b08b91"></span>int <code class="sig-name descname">isReordered</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler11isReorderedEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check whether a reordering has been applied to the nodes</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Flag indicating if the nodes have been reordered </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler13getReorderingEPi">
<span id="_CPPv3N13TACSAssembler13getReorderingEPi"></span><span id="_CPPv2N13TACSAssembler13getReorderingEPi"></span><span id="TACSAssembler::getReordering__iP"></span><span class="target" id="class_t_a_c_s_assembler_1abfd07e08305bbe8b850c99e32e94a1ad"></span>void <code class="sig-name descname">getReordering</code><span class="sig-paren">(</span>int *<em>oldToNew</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler13getReorderingEPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the ordering from the old nodes to the new nodes</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">oldToNew</span></code>: Array of size equal to the number of owned nodes </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler10reorderVecEP8TACSBVec">
<span id="_CPPv3N13TACSAssembler10reorderVecEP8TACSBVec"></span><span id="_CPPv2N13TACSAssembler10reorderVecEP8TACSBVec"></span><span id="TACSAssembler::reorderVec__TACSBVecP"></span><span class="target" id="class_t_a_c_s_assembler_1aac5cf9d2b25a58ab0c74b5285f3add4a"></span>void <code class="sig-name descname">reorderVec</code><span class="sig-paren">(</span>TACSBVec *<em>vec</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler10reorderVecEP8TACSBVec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reorder the vector using the reordering computed using the <a class="reference internal" href="#class_t_a_c_s_assembler_1aa48903b297d94836bebbad1b9c10cd74"><span class="std std-ref">computeReordering()</span></a> call.</p>
<p>This is useful for reordering nodal vectors after the reordering has been applied.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vec</span></code>: The vector to be reordered in place </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler12reorderNodesEiPi">
<span id="_CPPv3N13TACSAssembler12reorderNodesEiPi"></span><span id="_CPPv2N13TACSAssembler12reorderNodesEiPi"></span><span id="TACSAssembler::reorderNodes__i.iP"></span><span class="target" id="class_t_a_c_s_assembler_1a7b9629aea5a7ac7c161d6e3ee20efaa3"></span>void <code class="sig-name descname">reorderNodes</code><span class="sig-paren">(</span>int <em>num_nodes</em>, int *<em>nodes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler12reorderNodesEiPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reorder the nodes from the initial ordering to the final ordering</p>
<p>Note that this only works for the nodes that are owned locally. Non-local or local non-owned nodes will not be reordered properly.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">num_nodes</span></code>: The length of the nodes array </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nodes</span></code>: The owned node numbers that will be converted </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler10initializeEv">
<span id="_CPPv3N13TACSAssembler10initializeEv"></span><span id="_CPPv2N13TACSAssembler10initializeEv"></span><span id="TACSAssembler::initialize"></span><span class="target" id="class_t_a_c_s_assembler_1a25714da663c6930e11eb01a307eb5d53"></span>int <code class="sig-name descname">initialize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler10initializeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function initialize performs a number of synchronization tasks that prepare the finite-element model for use.</p>
<p>tacsNodeNums[i] is the global node number for the local node number i</p>
<p>Two objects are required:<ol class="arabic simple">
<li><p>NodeMap is constructed with the block sizes of each node owned by this process</p></li>
<li><p>VecDistribute is constructed so that it takes an array and distributes its values to a vector or takes the vector values and collects them into an array This requires a sorted array of global node numbers.</p></li>
</ol>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Fail flag indicating if a failure occured </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler10getMPICommEv">
<span id="_CPPv3N13TACSAssembler10getMPICommEv"></span><span id="_CPPv2N13TACSAssembler10getMPICommEv"></span><span id="TACSAssembler::getMPIComm"></span><span class="target" id="class_t_a_c_s_assembler_1a945a66acdffa5ec0b72b7e15342304f1"></span>MPI_Comm <code class="sig-name descname">getMPIComm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler10getMPICommEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the MPI communicator for the <a class="reference internal" href="#class_t_a_c_s_assembler"><span class="std std-ref">TACSAssembler</span></a> object</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the MPI communicator </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler13getThreadInfoEv">
<span id="_CPPv3N13TACSAssembler13getThreadInfoEv"></span><span id="_CPPv2N13TACSAssembler13getThreadInfoEv"></span><span id="TACSAssembler::getThreadInfo"></span><span class="target" id="class_t_a_c_s_assembler_1a82c20d0c96f03ba05a08886f35fa2af9"></span>TACSThreadInfo *<code class="sig-name descname">getThreadInfo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler13getThreadInfoEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the thread information from the <a class="reference internal" href="#class_t_a_c_s_assembler"><span class="std std-ref">TACSAssembler</span></a> object</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the thread info object </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler14getVarsPerNodeEv">
<span id="_CPPv3N13TACSAssembler14getVarsPerNodeEv"></span><span id="_CPPv2N13TACSAssembler14getVarsPerNodeEv"></span><span id="TACSAssembler::getVarsPerNode"></span><span class="target" id="class_t_a_c_s_assembler_1ab5886f8f9f50edd1a032b92d8bebc494"></span>int <code class="sig-name descname">getVarsPerNode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler14getVarsPerNodeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the number of degrees of freedom per node</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of degrees of freedom per node </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler20getDesignVarsPerNodeEv">
<span id="_CPPv3N13TACSAssembler20getDesignVarsPerNodeEv"></span><span id="_CPPv2N13TACSAssembler20getDesignVarsPerNodeEv"></span><span id="TACSAssembler::getDesignVarsPerNode"></span><span class="target" id="class_t_a_c_s_assembler_1a1a64b66765d8808bb6f4a016a3d6bc54"></span>int <code class="sig-name descname">getDesignVarsPerNode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler20getDesignVarsPerNodeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the number of design variables per &quot;node&quot;</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of design variables for each design &quot;node&quot; </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler11getNumNodesEv">
<span id="_CPPv3N13TACSAssembler11getNumNodesEv"></span><span id="_CPPv2N13TACSAssembler11getNumNodesEv"></span><span id="TACSAssembler::getNumNodes"></span><span class="target" id="class_t_a_c_s_assembler_1aa6a7443597cb979abeb84f6ea26e8656"></span>int <code class="sig-name descname">getNumNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler11getNumNodesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the number of local nodes</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of local nodes defined on this processor </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler20getNumDependentNodesEv">
<span id="_CPPv3N13TACSAssembler20getNumDependentNodesEv"></span><span id="_CPPv2N13TACSAssembler20getNumDependentNodesEv"></span><span id="TACSAssembler::getNumDependentNodes"></span><span class="target" id="class_t_a_c_s_assembler_1a2619a83d7057e6370eea3254b9a5f776"></span>int <code class="sig-name descname">getNumDependentNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler20getNumDependentNodesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the number of dependent nodes</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of dependent nodes defined on this processor </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler16getNumOwnedNodesEv">
<span id="_CPPv3N13TACSAssembler16getNumOwnedNodesEv"></span><span id="_CPPv2N13TACSAssembler16getNumOwnedNodesEv"></span><span id="TACSAssembler::getNumOwnedNodes"></span><span class="target" id="class_t_a_c_s_assembler_1a76c46c1666ab4df931213b31e4b6d12b"></span>int <code class="sig-name descname">getNumOwnedNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler16getNumOwnedNodesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the number of owned local nodes</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of locally owned nodes on this processor </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler14getNumElementsEv">
<span id="_CPPv3N13TACSAssembler14getNumElementsEv"></span><span id="_CPPv2N13TACSAssembler14getNumElementsEv"></span><span id="TACSAssembler::getNumElements"></span><span class="target" id="class_t_a_c_s_assembler_1ac822368aed2baa6233bad3aa0fd29764"></span>int <code class="sig-name descname">getNumElements</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler14getNumElementsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the number of elements</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The number of elements defined on this processor </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler10getNodeMapEv">
<span id="_CPPv3N13TACSAssembler10getNodeMapEv"></span><span id="_CPPv2N13TACSAssembler10getNodeMapEv"></span><span id="TACSAssembler::getNodeMap"></span><span class="target" id="class_t_a_c_s_assembler_1adb5802ba186398f8973f04004a907f5e"></span>TACSNodeMap *<code class="sig-name descname">getNodeMap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler10getNodeMapEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the node-processor assignment</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The map that defines the nodal assignment to each processor </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler16getDesignNodeMapEv">
<span id="_CPPv3N13TACSAssembler16getDesignNodeMapEv"></span><span id="_CPPv2N13TACSAssembler16getDesignNodeMapEv"></span><span id="TACSAssembler::getDesignNodeMap"></span><span class="target" id="class_t_a_c_s_assembler_1a2dce808aa22c1429f3366cd3d1905e84"></span>TACSNodeMap *<code class="sig-name descname">getDesignNodeMap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler16getDesignNodeMapEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the node-processor design variable assignment</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The map that defines the design variable assignment to each processor </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler8getBcMapEv">
<span id="_CPPv3N13TACSAssembler8getBcMapEv"></span><span id="_CPPv2N13TACSAssembler8getBcMapEv"></span><span id="TACSAssembler::getBcMap"></span><span class="target" id="class_t_a_c_s_assembler_1ad89cd73d864e9778eaa9a6a47777dc9a"></span>TACSBcMap *<code class="sig-name descname">getBcMap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler8getBcMapEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the boundary conditions</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The boundary conditions (may be NULL) </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler12getInitBcMapEv">
<span id="_CPPv3N13TACSAssembler12getInitBcMapEv"></span><span id="_CPPv2N13TACSAssembler12getInitBcMapEv"></span><span id="TACSAssembler::getInitBcMap"></span><span class="target" id="class_t_a_c_s_assembler_1a9217022eaee60d053d60aeb3a78dd7d1"></span>TACSBcMap *<code class="sig-name descname">getInitBcMap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler12getInitBcMapEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the additional boundary conditions associated with the initial conditions.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Initial boundary conditions (may be NULL) </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler17getBVecDistributeEv">
<span id="_CPPv3N13TACSAssembler17getBVecDistributeEv"></span><span id="_CPPv2N13TACSAssembler17getBVecDistributeEv"></span><span id="TACSAssembler::getBVecDistribute"></span><span class="target" id="class_t_a_c_s_assembler_1a1f303abb0e23c06d6a12bf5ded814b81"></span>TACSBVecDistribute *<code class="sig-name descname">getBVecDistribute</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler17getBVecDistributeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the vector distribution object</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The object for distributing vector values </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler15getBVecDepNodesEv">
<span id="_CPPv3N13TACSAssembler15getBVecDepNodesEv"></span><span id="_CPPv2N13TACSAssembler15getBVecDepNodesEv"></span><span id="TACSAssembler::getBVecDepNodes"></span><span class="target" id="class_t_a_c_s_assembler_1ae69145d846d2962c0dd3bca2245f053a"></span>TACSBVecDepNodes *<code class="sig-name descname">getBVecDepNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler15getBVecDepNodesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the dependent node vectors</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The object used to define the dependent node equations </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler18getMaxElementNodesEv">
<span id="_CPPv3N13TACSAssembler18getMaxElementNodesEv"></span><span id="_CPPv2N13TACSAssembler18getMaxElementNodesEv"></span><span id="TACSAssembler::getMaxElementNodes"></span><span class="target" id="class_t_a_c_s_assembler_1aed173d9ae7391992f62de89feecefc61"></span>int <code class="sig-name descname">getMaxElementNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler18getMaxElementNodesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the maximum number of nodes for an element</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The maximum number of nodes for an element </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler22getMaxElementVariablesEv">
<span id="_CPPv3N13TACSAssembler22getMaxElementVariablesEv"></span><span id="_CPPv2N13TACSAssembler22getMaxElementVariablesEv"></span><span id="TACSAssembler::getMaxElementVariables"></span><span class="target" id="class_t_a_c_s_assembler_1a7d06d9439994137a4bf677063be166ec"></span>int <code class="sig-name descname">getMaxElementVariables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler22getMaxElementVariablesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the maximum number of element variables</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The maximum number of variables for an element </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler23getMaxElementDesignVarsEv">
<span id="_CPPv3N13TACSAssembler23getMaxElementDesignVarsEv"></span><span id="_CPPv2N13TACSAssembler23getMaxElementDesignVarsEv"></span><span id="TACSAssembler::getMaxElementDesignVars"></span><span class="target" id="class_t_a_c_s_assembler_1ac9269463a7fe4db3d0606ef7bda19ccb"></span>int <code class="sig-name descname">getMaxElementDesignVars</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler23getMaxElementDesignVarsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the maximum number of design variables for an element</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The maximum number of design variables for an element </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler14setAuxElementsEP15TACSAuxElements">
<span id="_CPPv3N13TACSAssembler14setAuxElementsEP15TACSAuxElements"></span><span id="_CPPv2N13TACSAssembler14setAuxElementsEP15TACSAuxElements"></span><span id="TACSAssembler::setAuxElements__TACSAuxElementsP"></span><span class="target" id="class_t_a_c_s_assembler_1af85cb230d3bb5b6dd6d16e7cd883215d"></span>void <code class="sig-name descname">setAuxElements</code><span class="sig-paren">(</span>TACSAuxElements *<em>aux_elems</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler14setAuxElementsEP15TACSAuxElements" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the auxiliary elements within the <a class="reference internal" href="#class_t_a_c_s_assembler"><span class="std std-ref">TACSAssembler</span></a> object</p>
<p>This only needs to be done once sometime during initialization. If you need to change the loads repeatedly, this can be called repeatedly. No check is made at this point that you haven't done something odd. Note that the code assumes that the elements defined here perfectly overlap the non-zero pattern of the elements set internally within TACS already.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">auxElems</span></code>: Auxiliary element object </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler14getAuxElementsEv">
<span id="_CPPv3N13TACSAssembler14getAuxElementsEv"></span><span id="_CPPv2N13TACSAssembler14getAuxElementsEv"></span><span id="TACSAssembler::getAuxElements"></span><span class="target" id="class_t_a_c_s_assembler_1a42af5c1cf9ec8357fd317c2f3278684e"></span>TACSAuxElements *<code class="sig-name descname">getAuxElements</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler14getAuxElementsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve the auxiliary element object from <a class="reference internal" href="#class_t_a_c_s_assembler"><span class="std std-ref">TACSAssembler</span></a></p>
<p>Note that the auxiliary element object may be NULL</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The auxiliary element object </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler13createNodeVecEv">
<span id="_CPPv3N13TACSAssembler13createNodeVecEv"></span><span id="_CPPv2N13TACSAssembler13createNodeVecEv"></span><span id="TACSAssembler::createNodeVec"></span><span class="target" id="class_t_a_c_s_assembler_1a190042a00b0d7aa051fc42924740239a"></span>TACSBVec *<code class="sig-name descname">createNodeVec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler13createNodeVecEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a global vector of node locations.</p>
<p>Note that the nodal coordinates are not set into the vector.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>A new vector for spatial coordinates </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler8setNodesEP8TACSBVec">
<span id="_CPPv3N13TACSAssembler8setNodesEP8TACSBVec"></span><span id="_CPPv2N13TACSAssembler8setNodesEP8TACSBVec"></span><span id="TACSAssembler::setNodes__TACSBVecP"></span><span class="target" id="class_t_a_c_s_assembler_1a7438f2a9f4450665cd78bfbb21556b8c"></span>void <code class="sig-name descname">setNodes</code><span class="sig-paren">(</span>TACSBVec *<em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler8setNodesEP8TACSBVec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the nodal locations from the input vector</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">X</span></code>: The nodal coordinate vector </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler8getNodesEP8TACSBVec">
<span id="_CPPv3N13TACSAssembler8getNodesEP8TACSBVec"></span><span id="_CPPv2N13TACSAssembler8getNodesEP8TACSBVec"></span><span id="TACSAssembler::getNodes__TACSBVecP"></span><span class="target" id="class_t_a_c_s_assembler_1abcccc2898ea24a960ce0d08c4f705e76"></span>void <code class="sig-name descname">getNodes</code><span class="sig-paren">(</span>TACSBVec *<em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler8getNodesEP8TACSBVec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the node locations from TACS</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">X</span></code>: The nodal coordinates are copied into this vector </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler8getNodesEPP8TACSBVec">
<span id="_CPPv3N13TACSAssembler8getNodesEPP8TACSBVec"></span><span id="_CPPv2N13TACSAssembler8getNodesEPP8TACSBVec"></span><span id="TACSAssembler::getNodes__TACSBVecPP"></span><span class="target" id="class_t_a_c_s_assembler_1ad8a81398e8d3f00372514d2c991c7750"></span>void <code class="sig-name descname">getNodes</code><span class="sig-paren">(</span>TACSBVec **<em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler8getNodesEPP8TACSBVec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get a pointer to the internal nodal coordinate vector</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">X</span></code>: A pointer to the nodal coordinate vector used by this Assembler object </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler17setSimulationTimeEd">
<span id="_CPPv3N13TACSAssembler17setSimulationTimeEd"></span><span id="_CPPv2N13TACSAssembler17setSimulationTimeEd"></span><span id="TACSAssembler::setSimulationTime__double"></span><span class="target" id="class_t_a_c_s_assembler_1a1e5fb6db28770d496186b4643f0016d4"></span>void <code class="sig-name descname">setSimulationTime</code><span class="sig-paren">(</span>double <em>_time</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler17setSimulationTimeEd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the simulation time internally in the <a class="reference internal" href="#class_t_a_c_s_assembler"><span class="std std-ref">TACSAssembler</span></a> object</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">_time</span></code>: The simulation time </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler9createVecEv">
<span id="_CPPv3N13TACSAssembler9createVecEv"></span><span id="_CPPv2N13TACSAssembler9createVecEv"></span><span id="TACSAssembler::createVec"></span><span class="target" id="class_t_a_c_s_assembler_1a0380184c70f9414efaf0f4af234e4720"></span>TACSBVec *<code class="sig-name descname">createVec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler9createVecEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a distributed solution vector.</p>
<p>Vector classes initialized by one TACS object, cannot be used by a second, unless they share are exactly the parallel layout.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>A new, empty solution vector initialized to zero </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler8applyBCsEP7TACSVec">
<span id="_CPPv3N13TACSAssembler8applyBCsEP7TACSVec"></span><span id="_CPPv2N13TACSAssembler8applyBCsEP7TACSVec"></span><span id="TACSAssembler::applyBCs__TACSVecP"></span><span class="target" id="class_t_a_c_s_assembler_1abb863293676adabf5d94e5310726ce21"></span>void <code class="sig-name descname">applyBCs</code><span class="sig-paren">(</span>TACSVec *<em>vec</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler8applyBCsEP7TACSVec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Apply the boundary conditions associated with the regular boundary conditions. This zeros all entries in the vector associated with Dirichlet conditions.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vec</span></code>: Apply the boundary conditions to this vector </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler8applyBCsEP7TACSMat">
<span id="_CPPv3N13TACSAssembler8applyBCsEP7TACSMat"></span><span id="_CPPv2N13TACSAssembler8applyBCsEP7TACSMat"></span><span id="TACSAssembler::applyBCs__TACSMatP"></span><span class="target" id="class_t_a_c_s_assembler_1ab0fae1e8a82c48a686f3413cc2c9bc0b"></span>void <code class="sig-name descname">applyBCs</code><span class="sig-paren">(</span>TACSMat *<em>mat</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler8applyBCsEP7TACSMat" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Apply the boundary conditions to the matrix</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mat</span></code>: Apply the boundary conditions to the rows of this matrix </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler17applyTransposeBCsEP7TACSMat">
<span id="_CPPv3N13TACSAssembler17applyTransposeBCsEP7TACSMat"></span><span id="_CPPv2N13TACSAssembler17applyTransposeBCsEP7TACSMat"></span><span id="TACSAssembler::applyTransposeBCs__TACSMatP"></span><span class="target" id="class_t_a_c_s_assembler_1a787640f66504399278f87d96e0f27cad"></span>void <code class="sig-name descname">applyTransposeBCs</code><span class="sig-paren">(</span>TACSMat *<em>mat</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler17applyTransposeBCsEP7TACSMat" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Apply the boundary conditions to the tranpose of the matrix</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mat</span></code>: Apply the boundary conditions to the columns of this matrix </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler6setBCsEP7TACSVec">
<span id="_CPPv3N13TACSAssembler6setBCsEP7TACSVec"></span><span id="_CPPv2N13TACSAssembler6setBCsEP7TACSVec"></span><span id="TACSAssembler::setBCs__TACSVecP"></span><span class="target" id="class_t_a_c_s_assembler_1a2eca1b43a5c6ee27a7af1a9cf4246416"></span>void <code class="sig-name descname">setBCs</code><span class="sig-paren">(</span>TACSVec *<em>vec</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler6setBCsEP7TACSVec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the Dirichlet boundary conditions into the vector. This differs from applyBCs since the boundary condition values are set (not zeroed).</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vec</span></code>: Set the boundary conditions values into this vector </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler13zeroVariablesEv">
<span id="_CPPv3N13TACSAssembler13zeroVariablesEv"></span><span id="_CPPv2N13TACSAssembler13zeroVariablesEv"></span><span id="TACSAssembler::zeroVariables"></span><span class="target" id="class_t_a_c_s_assembler_1aae16ac11fe1daf0e3041de8448580592"></span>void <code class="sig-name descname">zeroVariables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler13zeroVariablesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Zero the entries of the local variables </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler16zeroDotVariablesEv">
<span id="_CPPv3N13TACSAssembler16zeroDotVariablesEv"></span><span id="_CPPv2N13TACSAssembler16zeroDotVariablesEv"></span><span id="TACSAssembler::zeroDotVariables"></span><span class="target" id="class_t_a_c_s_assembler_1abb09f4663623040e48bce9733887bd43"></span>void <code class="sig-name descname">zeroDotVariables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler16zeroDotVariablesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Zero the values of the time-derivatives of the state variables. This time-derivative is load-case independent. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler17zeroDDotVariablesEv">
<span id="_CPPv3N13TACSAssembler17zeroDDotVariablesEv"></span><span id="_CPPv2N13TACSAssembler17zeroDDotVariablesEv"></span><span id="TACSAssembler::zeroDDotVariables"></span><span class="target" id="class_t_a_c_s_assembler_1a316988f993f3bfb31a0f5120123396b6"></span>void <code class="sig-name descname">zeroDDotVariables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler17zeroDDotVariablesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Zero the values of the time-derivatives of the state variables. This time-derivative is load-case independent. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler12setVariablesEP8TACSBVecP8TACSBVecP8TACSBVec">
<span id="_CPPv3N13TACSAssembler12setVariablesEP8TACSBVecP8TACSBVecP8TACSBVec"></span><span id="_CPPv2N13TACSAssembler12setVariablesEP8TACSBVecP8TACSBVecP8TACSBVec"></span><span id="TACSAssembler::setVariables__TACSBVecP.TACSBVecP.TACSBVecP"></span><span class="target" id="class_t_a_c_s_assembler_1af5d6200ce18fe67ec4bbc2f61ab21b9c"></span>void <code class="sig-name descname">setVariables</code><span class="sig-paren">(</span>TACSBVec *<em>q</em>, TACSBVec *<em>qdot</em> = NULL, TACSBVec *<em>qddot</em> = NULL<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler12setVariablesEP8TACSBVecP8TACSBVecP8TACSBVec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the value of the time/variables/time derivatives simultaneously</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vars</span></code>: The variable values (may be NULL) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvars</span></code>: The time derivative values (may be NULL) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ddvars</span></code>: The second time derivative values (may be NULL) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler12getVariablesEP8TACSBVecP8TACSBVecP8TACSBVec">
<span id="_CPPv3N13TACSAssembler12getVariablesEP8TACSBVecP8TACSBVecP8TACSBVec"></span><span id="_CPPv2N13TACSAssembler12getVariablesEP8TACSBVecP8TACSBVecP8TACSBVec"></span><span id="TACSAssembler::getVariables__TACSBVecP.TACSBVecP.TACSBVecP"></span><span class="target" id="class_t_a_c_s_assembler_1aa4df80006af0c977276e9c41b6e41c00"></span>void <code class="sig-name descname">getVariables</code><span class="sig-paren">(</span>TACSBVec *<em>q</em>, TACSBVec *<em>qdot</em> = NULL, TACSBVec *<em>qddot</em> = NULL<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler12getVariablesEP8TACSBVecP8TACSBVecP8TACSBVec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the variables from the vectors in TACS</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vars</span></code>: The variable values (may be NULL) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvars</span></code>: The time derivative values (may be NULL) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ddvars</span></code>: The second time derivative values (may be NULL) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler12getVariablesEPP8TACSBVecPP8TACSBVecPP8TACSBVec">
<span id="_CPPv3N13TACSAssembler12getVariablesEPP8TACSBVecPP8TACSBVecPP8TACSBVec"></span><span id="_CPPv2N13TACSAssembler12getVariablesEPP8TACSBVecPP8TACSBVecPP8TACSBVec"></span><span id="TACSAssembler::getVariables__TACSBVecPP.TACSBVecPP.TACSBVecPP"></span><span class="target" id="class_t_a_c_s_assembler_1a161f58c9620878e2a771256482fdcc4f"></span>void <code class="sig-name descname">getVariables</code><span class="sig-paren">(</span>TACSBVec **<em>q</em>, TACSBVec **<em>qdot</em> = NULL, TACSBVec **<em>qddot</em> = NULL<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler12getVariablesEPP8TACSBVecPP8TACSBVecPP8TACSBVec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the variables from the vectors in TACS</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vars</span></code>: The variable values (may be NULL) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvars</span></code>: The time derivative values (may be NULL) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ddvars</span></code>: The second time derivative values (may be NULL) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler13copyVariablesEP8TACSBVecP8TACSBVecP8TACSBVec">
<span id="_CPPv3N13TACSAssembler13copyVariablesEP8TACSBVecP8TACSBVecP8TACSBVec"></span><span id="_CPPv2N13TACSAssembler13copyVariablesEP8TACSBVecP8TACSBVecP8TACSBVec"></span><span id="TACSAssembler::copyVariables__TACSBVecP.TACSBVecP.TACSBVecP"></span><span class="target" id="class_t_a_c_s_assembler_1ad883fb41ec3367186622a3170a42beb3"></span>void <code class="sig-name descname">copyVariables</code><span class="sig-paren">(</span>TACSBVec *<em>q</em>, TACSBVec *<em>qdot</em> = NULL, TACSBVec *<em>qddot</em> = NULL<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler13copyVariablesEP8TACSBVecP8TACSBVecP8TACSBVec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy the values directly without distributing them.</p>
<p>This is designed for specific instances where you want to use the values in the vector directly without distributing them. This means that the variable values may be inconsistent across processors. This is not usually what you want to do.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vars</span></code>: The variable values (may be NULL) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvars</span></code>: The time derivative values (may be NULL) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ddvars</span></code>: The second time derivative values (may be NULL) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler9createMatEv">
<span id="_CPPv3N13TACSAssembler9createMatEv"></span><span id="_CPPv2N13TACSAssembler9createMatEv"></span><span id="TACSAssembler::createMat"></span><span class="target" id="class_t_a_c_s_assembler_1a43327a8b4a24b1d62d15479c8b7fad26"></span>TACSParallelMat *<code class="sig-name descname">createMat</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler9createMatEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a distributed matrix</p>
<p>This matrix is distributed in block-rows. Each processor owns a local part of the matrix and an off-diagonal part which couples between processors.</p>
<p>This code creates a local array of global indices that is used to determine the destination for each entry in the sparse matrix. This TACSBVecIndices object is reused if any subsequent parMat objects are created.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>A new parallel matrix with zeroed entries </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler14createSchurMatE12OrderingType">
<span id="_CPPv3N13TACSAssembler14createSchurMatE12OrderingType"></span><span id="_CPPv2N13TACSAssembler14createSchurMatE12OrderingType"></span><span id="TACSAssembler::createSchurMat__OrderingType"></span><span class="target" id="class_t_a_c_s_assembler_1a106c232ade9559f196446add5c80b186"></span>TACSSchurMat *<code class="sig-name descname">createSchurMat</code><span class="sig-paren">(</span>OrderingType <em>order_type</em> = TACS_AMD_ORDER<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler14createSchurMatE12OrderingType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a parallel matrix for finite-element analysis.</p>
<p>On the first call, this computes a reordering with the scheme provided. On subsequent calls, the reordering scheme is reused so that all TACSSchurMats, created from the same <a class="reference internal" href="#class_t_a_c_s_assembler"><span class="std std-ref">TACSAssembler</span></a> object have the same non-zero structure. This makes adding matrices together easier (which is required for eigenvalue computations.)</p>
<p>The first step is to determine the coupling nodes. (For a serial case there are no coupling nodes, so this is very simple!) Then, the nodes that are not coupled to other processes are determined. The coupling and non-coupling nodes are ordered separately. The coupling nodes must be ordered at the end of the block, while the local nodes must be ordered first. This type of constraint is not usually imposed in matrix ordering routines, so here we use a kludge. First, order all the nodes and determine the ordering of the coupling variables within the full set. Next, order the local nodes. This hopefully reduces the fill-ins required, although there is no firm proof to back that up.</p>
<p>The results from the reordering are placed in a set of objects. The matrix reordering is stored in schurBIndices and schurCIndices while two mapping objects are created that map the variables from the global vector to reordered matrix.</p>
<p>Mathematically this reordering can be written as follows,</p>
<p>A' = (P A P^{T})</p>
<p>where P^{T} is a permutation of the columns (variables), while P is a permutation of the rows (equations).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>A new TACSSchurMat matrix with zeroed entries </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">order_type</span></code>: Order the Schur matrix with this type of ordeirng </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler17getInitConditionsEP8TACSBVecP8TACSBVecP8TACSBVec">
<span id="_CPPv3N13TACSAssembler17getInitConditionsEP8TACSBVecP8TACSBVecP8TACSBVec"></span><span id="_CPPv2N13TACSAssembler17getInitConditionsEP8TACSBVecP8TACSBVecP8TACSBVec"></span><span id="TACSAssembler::getInitConditions__TACSBVecP.TACSBVecP.TACSBVecP"></span><span class="target" id="class_t_a_c_s_assembler_1a389c21846e6ca3cc2f70d73e65a75a2d"></span>void <code class="sig-name descname">getInitConditions</code><span class="sig-paren">(</span>TACSBVec *<em>vars</em>, TACSBVec *<em>dvars</em>, TACSBVec *<em>ddvars</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler17getInitConditionsEP8TACSBVecP8TACSBVecP8TACSBVec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve the initial conditions associated with the problem</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vars</span></code>: The initial variable values (may be NULL) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvars</span></code>: The initial time derivative values (may be NULL) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ddvars</span></code>: The initial second time derivative values (may be NULL) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler12evalEnergiesEP10TacsScalarP10TacsScalar">
<span id="_CPPv3N13TACSAssembler12evalEnergiesEP10TacsScalarP10TacsScalar"></span><span id="_CPPv2N13TACSAssembler12evalEnergiesEP10TacsScalarP10TacsScalar"></span><span id="TACSAssembler::evalEnergies__TacsScalarP.TacsScalarP"></span><span class="target" id="class_t_a_c_s_assembler_1ab41309d5d4141db59164c21c9b36d766"></span>void <code class="sig-name descname">evalEnergies</code><span class="sig-paren">(</span>TacsScalar *<em>Te</em>, TacsScalar *<em>Pe</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler12evalEnergiesEP10TacsScalarP10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Evaluates the total kinetic and potential energies of the structure</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Te</span></code>: The kinetic energy </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Pe</span></code>: The potential energy </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler11assembleResEP8TACSBVec">
<span id="_CPPv3N13TACSAssembler11assembleResEP8TACSBVec"></span><span id="_CPPv2N13TACSAssembler11assembleResEP8TACSBVec"></span><span id="TACSAssembler::assembleRes__TACSBVecP"></span><span class="target" id="class_t_a_c_s_assembler_1afa3cdd956f80bd6a2011866072a5e80e"></span>void <code class="sig-name descname">assembleRes</code><span class="sig-paren">(</span>TACSBVec *<em>residual</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler11assembleResEP8TACSBVec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assemble the residual</p>
<p>This residual includes the contributions from element tractions set in the auxiliary element classes. Note that the vector entries are zeroed first, and that the Dirichlet boundary conditions are applied after the assembly of the residual is complete.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">residual</span></code>: The residual vector </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler16assembleJacobianE10TacsScalar10TacsScalar10TacsScalarP8TACSBVecP7TACSMat17MatrixOrientation">
<span id="_CPPv3N13TACSAssembler16assembleJacobianE10TacsScalar10TacsScalar10TacsScalarP8TACSBVecP7TACSMat17MatrixOrientation"></span><span id="_CPPv2N13TACSAssembler16assembleJacobianE10TacsScalar10TacsScalar10TacsScalarP8TACSBVecP7TACSMat17MatrixOrientation"></span><span id="TACSAssembler::assembleJacobian__TacsScalar.TacsScalar.TacsScalar.TACSBVecP.TACSMatP.MatrixOrientation"></span><span class="target" id="class_t_a_c_s_assembler_1a34b1d3203d786ebba79826bc265c5529"></span>void <code class="sig-name descname">assembleJacobian</code><span class="sig-paren">(</span>TacsScalar <em>alpha</em>, TacsScalar <em>beta</em>, TacsScalar <em>gamma</em>, TACSBVec *<em>residual</em>, TACSMat *<em>A</em>, MatrixOrientation <em>matOr</em> = TACS_MAT_NORMAL<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler16assembleJacobianE10TacsScalar10TacsScalar10TacsScalarP8TACSBVecP7TACSMat17MatrixOrientation" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assemble the Jacobian matrix</p>
<p>This function assembles the global Jacobian matrix and residual. This Jacobian includes the contributions from all elements. The Dirichlet boundary conditions are applied to the matrix by zeroing the rows of the matrix associated with a boundary condition, and setting the diagonal to unity. The matrix assembly also performs any communication required so that the matrix can be used immediately after assembly.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">alpha</span></code>: Coefficient for the variables </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">beta</span></code>: Coefficient for the time-derivative terms </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gamma</span></code>: Coefficientfor the second time derivative term </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">residual</span></code>: The residual of the governing equations </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code>: The Jacobian matrix </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">matOr</span></code>: the matrix orientation NORMAL or TRANSPOSE </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler15assembleMatTypeE17ElementMatrixTypeP7TACSMat17MatrixOrientation">
<span id="_CPPv3N13TACSAssembler15assembleMatTypeE17ElementMatrixTypeP7TACSMat17MatrixOrientation"></span><span id="_CPPv2N13TACSAssembler15assembleMatTypeE17ElementMatrixTypeP7TACSMat17MatrixOrientation"></span><span id="TACSAssembler::assembleMatType__ElementMatrixType.TACSMatP.MatrixOrientation"></span><span class="target" id="class_t_a_c_s_assembler_1ac70ae06294d140c6fcb919c2e57da1f4"></span>void <code class="sig-name descname">assembleMatType</code><span class="sig-paren">(</span>ElementMatrixType <em>matType</em>, TACSMat *<em>A</em>, MatrixOrientation <em>matOr</em> = TACS_MAT_NORMAL<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler15assembleMatTypeE17ElementMatrixTypeP7TACSMat17MatrixOrientation" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assemble a matrix of a specified type. Note that all matrices created from the <a class="reference internal" href="#class_t_a_c_s_assembler"><span class="std std-ref">TACSAssembler</span></a> object have the same non-zero pattern and are interchangable.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">matType</span></code>: The matrix type </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code>: The matrix to assemble (output) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">matOr</span></code>: The matrix orientation: NORMAL or TRANSPOSE </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler16assembleMatComboEA_17ElementMatrixTypeA_10TacsScalariP7TACSMat17MatrixOrientation">
<span id="_CPPv3N13TACSAssembler16assembleMatComboEA_17ElementMatrixTypeA_10TacsScalariP7TACSMat17MatrixOrientation"></span><span id="_CPPv2N13TACSAssembler16assembleMatComboEA_17ElementMatrixTypeA_10TacsScalariP7TACSMat17MatrixOrientation"></span><span id="TACSAssembler::assembleMatCombo__ElementMatrixTypeA.TacsScalarA.i.TACSMatP.MatrixOrientation"></span><span class="target" id="class_t_a_c_s_assembler_1ae48863f27190996b4dd4120d52205d4e"></span>void <code class="sig-name descname">assembleMatCombo</code><span class="sig-paren">(</span>ElementMatrixType <em>matTypes</em>[], TacsScalar <em>scale</em>[], int <em>nmats</em>, TACSMat *<em>A</em>, MatrixOrientation <em>matOr</em> = TACS_MAT_NORMAL<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler16assembleMatComboEA_17ElementMatrixTypeA_10TacsScalariP7TACSMat17MatrixOrientation" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assemble a linear combination of matrices.</p>
<p>This is used for some buckling/eigenvalue computations which require matrices that are linear combinations of specific types.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">matTypes</span></code>: The array of matrix types </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">scale</span></code>: The array of scalar values </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nmats</span></code>: The number of matrices in the linear combination </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code>: The matrix to assemble (output) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">matOr</span></code>: the matrix orientation: NORMAL or TRANSPOSE </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler21addJacobianVecProductE10TacsScalar10TacsScalar10TacsScalar10TacsScalarP8TACSBVecP8TACSBVec17MatrixOrientation">
<span id="_CPPv3N13TACSAssembler21addJacobianVecProductE10TacsScalar10TacsScalar10TacsScalar10TacsScalarP8TACSBVecP8TACSBVec17MatrixOrientation"></span><span id="_CPPv2N13TACSAssembler21addJacobianVecProductE10TacsScalar10TacsScalar10TacsScalar10TacsScalarP8TACSBVecP8TACSBVec17MatrixOrientation"></span><span id="TACSAssembler::addJacobianVecProduct__TacsScalar.TacsScalar.TacsScalar.TacsScalar.TACSBVecP.TACSBVecP.MatrixOrientation"></span><span class="target" id="class_t_a_c_s_assembler_1ae6d8b38cc1e96e29e99c0170bdb79079"></span>void <code class="sig-name descname">addJacobianVecProduct</code><span class="sig-paren">(</span>TacsScalar <em>scale</em>, TacsScalar <em>alpha</em>, TacsScalar <em>beta</em>, TacsScalar <em>gamma</em>, TACSBVec *<em>x</em>, TACSBVec *<em>y</em>, MatrixOrientation <em>matOr</em> = TACS_MAT_NORMAL<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler21addJacobianVecProductE10TacsScalar10TacsScalar10TacsScalar10TacsScalarP8TACSBVecP8TACSBVec17MatrixOrientation" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Evaluate the matrix-free Jacobian-vector product of the input vector x and store the result in the output vector y.</p>
<p>This code does not assemble a matrix, but does compute the element-wise matricies. This code is not a finite-difference matrix-vector product implementation.</p>
<p>Since the element Jacobian matrices are computed exactly, we can evaluate either a regular matrix-product or the transpose matrix product.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">scale</span></code>: The scalar coefficient </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">alpha</span></code>: Coefficient on the variables </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">beta</span></code>: Coefficient on the time-derivative terms </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gamma</span></code>: Coefficient on the second time derivative term </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code>: The input vector </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code>: the output vector y &lt;- y + scale*J^{Op}*x </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">matOr</span></code>: The matrix orientation </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler15createDesignVecEv">
<span id="_CPPv3N13TACSAssembler15createDesignVecEv"></span><span id="_CPPv2N13TACSAssembler15createDesignVecEv"></span><span id="TACSAssembler::createDesignVec"></span><span class="target" id="class_t_a_c_s_assembler_1a16606993f162e0d34a406ce1e0dfea82"></span>TACSBVec *<code class="sig-name descname">createDesignVec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler15createDesignVecEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a distributed design vector</p>
<p>Vector classes initialized by one TACS object, cannot be used by a second, unless they share are exactly the parallel layout.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>A new design variable vector </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler13getDesignVarsEP8TACSBVec">
<span id="_CPPv3N13TACSAssembler13getDesignVarsEP8TACSBVec"></span><span id="_CPPv2N13TACSAssembler13getDesignVarsEP8TACSBVec"></span><span id="TACSAssembler::getDesignVars__TACSBVecP"></span><span class="target" id="class_t_a_c_s_assembler_1a3790175b7fd4053cd9e44dd00200bac6"></span>void <code class="sig-name descname">getDesignVars</code><span class="sig-paren">(</span>TACSBVec *<em>dvs</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler13getDesignVarsEP8TACSBVec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Collect all the design variable values assigned by this process</p>
<p>This code does not ensure consistency of the design variable values between processes. If the values of the design variables are inconsistent to begin with. Call setDesignVars to force consistency.</p>
<p>Each process contains objects that maintain their own design variable values. Ensuring the consistency of the ordering is up to the user. Having multiply-defined design variable numbers corresponding to different design variables results in undefined behaviour.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dvs</span></code>: The vector of design variables </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler13setDesignVarsEP8TACSBVec">
<span id="_CPPv3N13TACSAssembler13setDesignVarsEP8TACSBVec"></span><span id="_CPPv2N13TACSAssembler13setDesignVarsEP8TACSBVec"></span><span id="TACSAssembler::setDesignVars__TACSBVecP"></span><span class="target" id="class_t_a_c_s_assembler_1a89e3684831e18e5c66380960faa54bce"></span>void <code class="sig-name descname">setDesignVars</code><span class="sig-paren">(</span>TACSBVec *<em>dvs</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler13setDesignVarsEP8TACSBVec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the design variables.</p>
<p>The design variable values provided must be the same on all processes for consistency. This must be called by all processors.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dvs</span></code>: The design variable values </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler17getDesignVarRangeEP8TACSBVecP8TACSBVec">
<span id="_CPPv3N13TACSAssembler17getDesignVarRangeEP8TACSBVecP8TACSBVec"></span><span id="_CPPv2N13TACSAssembler17getDesignVarRangeEP8TACSBVecP8TACSBVec"></span><span id="TACSAssembler::getDesignVarRange__TACSBVecP.TACSBVecP"></span><span class="target" id="class_t_a_c_s_assembler_1aeb0cd8600df335e98a09aca503521015"></span>void <code class="sig-name descname">getDesignVarRange</code><span class="sig-paren">(</span>TACSBVec *<em>lb</em>, TACSBVec *<em>ub</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler17getDesignVarRangeEP8TACSBVecP8TACSBVec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve the design variable range.</p>
<p>This call is collective on all TACS processes. The ranges provided by indivdual objects may not be consistent (if someone provided incorrect data they could be.)</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">lb</span></code>: the lower bound on the design variables </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ub</span></code>: the upper bound on the design variables </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler13evalFunctionsEiPP12TACSFunctionP10TacsScalar">
<span id="_CPPv3N13TACSAssembler13evalFunctionsEiPP12TACSFunctionP10TacsScalar"></span><span id="_CPPv2N13TACSAssembler13evalFunctionsEiPP12TACSFunctionP10TacsScalar"></span><span id="TACSAssembler::evalFunctions__i.TACSFunctionPP.TacsScalarP"></span><span class="target" id="class_t_a_c_s_assembler_1a960d6a4fb194573f3d1361d38109ddff"></span>void <code class="sig-name descname">evalFunctions</code><span class="sig-paren">(</span>int <em>numFuncs</em>, TACSFunction **<em>funcs</em>, TacsScalar *<em>funcVals</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler13evalFunctionsEiPP12TACSFunctionP10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Evaluate a list of TACS functions</p>
<p>First, check if the functions are initialized. Obtain the number of iterations over the function domain required to evaluate the functions.</p>
<p>This function will print an error and return 0 if the underlying <a class="reference internal" href="#class_t_a_c_s_assembler"><span class="std std-ref">TACSAssembler</span></a> object does not correspond to the <a class="reference internal" href="#class_t_a_c_s_assembler"><span class="std std-ref">TACSAssembler</span></a> object.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">numFuncs</span></code>: The number of functions to evaluate </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">funcs</span></code>: Array of functions to evaluate </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">funcVals</span></code>: The function values </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler9addDVSensE10TacsScalariPP12TACSFunctionPP8TACSBVec">
<span id="_CPPv3N13TACSAssembler9addDVSensE10TacsScalariPP12TACSFunctionPP8TACSBVec"></span><span id="_CPPv2N13TACSAssembler9addDVSensE10TacsScalariPP12TACSFunctionPP8TACSBVec"></span><span id="TACSAssembler::addDVSens__TacsScalar.i.TACSFunctionPP.TACSBVecPP"></span><span class="target" id="class_t_a_c_s_assembler_1ab487f81afef7ad75ff73a5455951ec88"></span>void <code class="sig-name descname">addDVSens</code><span class="sig-paren">(</span>TacsScalar <em>coef</em>, int <em>numFuncs</em>, TACSFunction **<em>funcs</em>, TACSBVec **<em>dfdx</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler9addDVSensE10TacsScalariPP12TACSFunctionPP8TACSBVec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Evaluate the derivative of a list of functions w.r.t. the design variables.</p>
<p>Note that a function should be evaluated - using evalFunction - before its derivatives can be evaluated.</p>
<p>The design variable sensitivities are divided into two distinct sets: material-dependent design variables and shape design variables. The shape design variables are handled through the TACSNodeMap class. The material-dependent design variables are handled through the element classes themselves.</p>
<p>In this code, the derivative of the function w.r.t. the shape-dependent design variables is handled first. The derivative of the function w.r.t each nodal location is determined. The TACSNodeMap object (if not NULL) is then used to determine the derivative of the nodal locations w.r.t. the design variables themselves.</p>
<p>The material-dependent design variables are handled on an element-by-element and traction-by-traction dependent basis.</p>
<p>Note that this function distributes the result to the processors through a collective communication call. No further parallel communication is required.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">coef</span></code>: The coefficient applied to the derivative </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numFuncs</span></code>: The number of functions - size of funcs array </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">funcs</span></code>: The TACSFunction function objects </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfdx</span></code>: The derivative vector </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler9addSVSensE10TacsScalar10TacsScalar10TacsScalariPP12TACSFunctionPP8TACSBVec">
<span id="_CPPv3N13TACSAssembler9addSVSensE10TacsScalar10TacsScalar10TacsScalariPP12TACSFunctionPP8TACSBVec"></span><span id="_CPPv2N13TACSAssembler9addSVSensE10TacsScalar10TacsScalar10TacsScalariPP12TACSFunctionPP8TACSBVec"></span><span id="TACSAssembler::addSVSens__TacsScalar.TacsScalar.TacsScalar.i.TACSFunctionPP.TACSBVecPP"></span><span class="target" id="class_t_a_c_s_assembler_1a33a52783b5d9bb48a018d8712f738ee4"></span>void <code class="sig-name descname">addSVSens</code><span class="sig-paren">(</span>TacsScalar <em>alpha</em>, TacsScalar <em>beta</em>, TacsScalar <em>gamma</em>, int <em>numFuncs</em>, TACSFunction **<em>funcs</em>, TACSBVec **<em>dfdu</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler9addSVSensE10TacsScalar10TacsScalar10TacsScalariPP12TACSFunctionPP8TACSBVec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Evaluate the derivative of the function w.r.t. the state variables.</p>
<p>This code evaluates the sensitivity of the function w.r.t. the state variables for all elements in the function domain. This code is usually much faster than the code for computing the derivative of the function w.r.t. the design variables.</p>
<p>Note that the sensitivity vector 'vec' is assembled, and appropriate boundary conditions are imposed before the function is returned.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">alpha</span></code>: Coefficient for the variables </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">beta</span></code>: Coefficient for the time-derivative terms </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gamma</span></code>: Coefficientfor the second time derivative term </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numFuncs</span></code>: The number of functions - size of funcs array </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">funcs</span></code>: The TACSFunction function objects </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfdu</span></code>: The derivative array </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler21addAdjointResProductsE10TacsScalariPP8TACSBVecPP8TACSBVec">
<span id="_CPPv3N13TACSAssembler21addAdjointResProductsE10TacsScalariPP8TACSBVecPP8TACSBVec"></span><span id="_CPPv2N13TACSAssembler21addAdjointResProductsE10TacsScalariPP8TACSBVecPP8TACSBVec"></span><span id="TACSAssembler::addAdjointResProducts__TacsScalar.i.TACSBVecPP.TACSBVecPP"></span><span class="target" id="class_t_a_c_s_assembler_1a893017245442a8a816124d815029b616"></span>void <code class="sig-name descname">addAdjointResProducts</code><span class="sig-paren">(</span>TacsScalar <em>scale</em>, int <em>numAdjoints</em>, TACSBVec **<em>adjoint</em>, TACSBVec **<em>dfdx</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler21addAdjointResProductsE10TacsScalariPP8TACSBVecPP8TACSBVec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Evaluate the product of several ajdoint vectors with the derivative of the residual w.r.t. the design variables.</p>
<p>This function is collective on all <a class="reference internal" href="#class_t_a_c_s_assembler"><span class="std std-ref">TACSAssembler</span></a> processes. This computes the product of the derivative of the residual w.r.t. the design variables with several adjoint vectors simultaneously. This saves computational time as the derivative of the element residuals can be reused for each adjoint vector. This function performs the same task as evalAdjointResProduct, but uses more memory than calling it for each adjoint vector.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">scale</span></code>: Scalar factor applied to the derivative </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numAdjoints</span></code>: The number of adjoint vectors </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">adjoint</span></code>: The array of adjoint vectors </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfdx</span></code>: Product of the derivative of the residuals and the adjoint </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler10addXptSensE10TacsScalariPP12TACSFunctionPP8TACSBVec">
<span id="_CPPv3N13TACSAssembler10addXptSensE10TacsScalariPP12TACSFunctionPP8TACSBVec"></span><span id="_CPPv2N13TACSAssembler10addXptSensE10TacsScalariPP12TACSFunctionPP8TACSBVec"></span><span id="TACSAssembler::addXptSens__TacsScalar.i.TACSFunctionPP.TACSBVecPP"></span><span class="target" id="class_t_a_c_s_assembler_1ac9057ccf54296f2f4253bd5ac6593820"></span>void <code class="sig-name descname">addXptSens</code><span class="sig-paren">(</span>TacsScalar <em>coef</em>, int <em>numFuncs</em>, TACSFunction **<em>funcs</em>, TACSBVec **<em>dfdXpts</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler10addXptSensE10TacsScalariPP12TACSFunctionPP8TACSBVec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Evaluate the derivative of the function w.r.t. the owned nodes.</p>
<p>This code evaluates the sensitivity of the function w.r.t. the owned nodes for all elements in the function domain.</p>
<p>Note that a function should be evaluated - using evalFunction - before its derivatives can be evaluated.</p>
<p>This function should be preferred to the use of evalDVSens without a list of functions since it is more efficient!</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">coef</span></code>: The coefficient applied to the derivative </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numFuncs</span></code>: The number of functions - size of funcs array </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">funcs</span></code>: The TACSFunction function objects </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfdXpt</span></code>: The derivative vector </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler28addAdjointResXptSensProductsE10TacsScalariPP8TACSBVecPP8TACSBVec">
<span id="_CPPv3N13TACSAssembler28addAdjointResXptSensProductsE10TacsScalariPP8TACSBVecPP8TACSBVec"></span><span id="_CPPv2N13TACSAssembler28addAdjointResXptSensProductsE10TacsScalariPP8TACSBVecPP8TACSBVec"></span><span id="TACSAssembler::addAdjointResXptSensProducts__TacsScalar.i.TACSBVecPP.TACSBVecPP"></span><span class="target" id="class_t_a_c_s_assembler_1ab9937a84a5b52e1ebf109df1e900e17d"></span>void <code class="sig-name descname">addAdjointResXptSensProducts</code><span class="sig-paren">(</span>TacsScalar <em>scale</em>, int <em>numAdjoints</em>, TACSBVec **<em>adjoint</em>, TACSBVec **<em>dfdXpts</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler28addAdjointResXptSensProductsE10TacsScalariPP8TACSBVecPP8TACSBVec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Evaluate the product of several ajdoint vectors with the derivative of the residual w.r.t. the nodal points.</p>
<p>This function is collective on all <a class="reference internal" href="#class_t_a_c_s_assembler"><span class="std std-ref">TACSAssembler</span></a> processes. This computes the product of the derivative of the residual w.r.t. the nodal points with several adjoint vectors simultaneously. This saves computational time as the derivative of the element residuals can be reused for each adjoint vector.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">scale</span></code>: Scalar factor applied to the derivative </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numAdjoints</span></code>: The number of adjoint vectors </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">adjoint</span></code>: The array of adjoint vectors </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfdXpt</span></code>: Product of the derivative of the residuals and the adjoint </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler18integrateFunctionsE10TacsScalarN12TACSFunction14EvaluationTypeEiPP12TACSFunction">
<span id="_CPPv3N13TACSAssembler18integrateFunctionsE10TacsScalarN12TACSFunction14EvaluationTypeEiPP12TACSFunction"></span><span id="_CPPv2N13TACSAssembler18integrateFunctionsE10TacsScalarN12TACSFunction14EvaluationTypeEiPP12TACSFunction"></span><span id="TACSAssembler::integrateFunctions__TacsScalar.TACSFunction::EvaluationType.i.TACSFunctionPP"></span><span class="target" id="class_t_a_c_s_assembler_1ad5b8b3d78f43a6efc5260a61361f79b8"></span>void <code class="sig-name descname">integrateFunctions</code><span class="sig-paren">(</span>TacsScalar <em>tcoef</em>, TACSFunction::EvaluationType <em>ftype</em>, int <em>numFuncs</em>, TACSFunction **<em>funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler18integrateFunctionsE10TacsScalarN12TACSFunction14EvaluationTypeEiPP12TACSFunction" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Integrate or initialize functions for a single time step of a time integration (or steady-state simulation).</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tcoef</span></code>: The integration coefficient </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ftype</span></code>: The type of integration to use </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numFuncs</span></code>: The number of functions </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">funcs</span></code>: The array of functions </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler24addMatDVSensInnerProductE10TacsScalar17ElementMatrixTypeP8TACSBVecP8TACSBVecP8TACSBVec">
<span id="_CPPv3N13TACSAssembler24addMatDVSensInnerProductE10TacsScalar17ElementMatrixTypeP8TACSBVecP8TACSBVecP8TACSBVec"></span><span id="_CPPv2N13TACSAssembler24addMatDVSensInnerProductE10TacsScalar17ElementMatrixTypeP8TACSBVecP8TACSBVecP8TACSBVec"></span><span id="TACSAssembler::addMatDVSensInnerProduct__TacsScalar.ElementMatrixType.TACSBVecP.TACSBVecP.TACSBVecP"></span><span class="target" id="class_t_a_c_s_assembler_1a8eef4a4612e6939dbfa8891ddb6ad489"></span>void <code class="sig-name descname">addMatDVSensInnerProduct</code><span class="sig-paren">(</span>TacsScalar <em>scale</em>, ElementMatrixType <em>matType</em>, TACSBVec *<em>psi</em>, TACSBVec *<em>phi</em>, TACSBVec *<em>dfdx</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler24addMatDVSensInnerProductE10TacsScalar17ElementMatrixTypeP8TACSBVecP8TACSBVecP8TACSBVec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Evaluate the derivative of an inner product of two vectors with a matrix of a given type. This code does not explicitly evaluate the element matrices. Instead, the inner product contribution from each element matrix is added to the final result. This implementation saves considerable computational time and memory.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">scale</span></code>: Scalar factor applied to the result </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">matType</span></code>: The type of matrix </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">psi</span></code>: The left-multiplying vector </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">phi</span></code>: The right-multiplying vector </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfdx</span></code>: The derivative vector </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler25evalMatSVSensInnerProductE17ElementMatrixTypeP8TACSBVecP8TACSBVecP8TACSBVec">
<span id="_CPPv3N13TACSAssembler25evalMatSVSensInnerProductE17ElementMatrixTypeP8TACSBVecP8TACSBVecP8TACSBVec"></span><span id="_CPPv2N13TACSAssembler25evalMatSVSensInnerProductE17ElementMatrixTypeP8TACSBVecP8TACSBVecP8TACSBVec"></span><span id="TACSAssembler::evalMatSVSensInnerProduct__ElementMatrixType.TACSBVecP.TACSBVecP.TACSBVecP"></span><span class="target" id="class_t_a_c_s_assembler_1a87c73b4b04fde7f4e2e9599c8e9e420c"></span>void <code class="sig-name descname">evalMatSVSensInnerProduct</code><span class="sig-paren">(</span>ElementMatrixType <em>matType</em>, TACSBVec *<em>psi</em>, TACSBVec *<em>phi</em>, TACSBVec *<em>res</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler25evalMatSVSensInnerProductE17ElementMatrixTypeP8TACSBVecP8TACSBVecP8TACSBVec" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Evaluate the derivative of the inner product of two vectors with a matrix with respect to the state variables. This is only defined for nonlinear matrices, like the geometric stiffness matrix. Instead of computing the derivative of the matrix for each vector component and then computing the inner product, this code computes the derivative of the inner product directly, saving computational time and memory.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">matType</span></code>: The type of matrix </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">psi</span></code>: The left-multiplying vector </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">phi</span></code>: The right-multiplying vector </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfdu</span></code>: The derivative of the inner product w.r.t. the state vars </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler11getElementsEv">
<span id="_CPPv3N13TACSAssembler11getElementsEv"></span><span id="_CPPv2N13TACSAssembler11getElementsEv"></span><span id="TACSAssembler::getElements"></span><span class="target" id="class_t_a_c_s_assembler_1ac6468e900ba8af3f97bc6195c3e6c99c"></span><a class="reference internal" href="#_CPPv411TACSElement" title="TACSElement">TACSElement</a> **<code class="sig-name descname">getElements</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler11getElementsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the array of elements from <a class="reference internal" href="#class_t_a_c_s_assembler"><span class="std std-ref">TACSAssembler</span></a></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The array of element objects </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler10getElementEiP10TacsScalarP10TacsScalarP10TacsScalarP10TacsScalar">
<span id="_CPPv3N13TACSAssembler10getElementEiP10TacsScalarP10TacsScalarP10TacsScalarP10TacsScalar"></span><span id="_CPPv2N13TACSAssembler10getElementEiP10TacsScalarP10TacsScalarP10TacsScalarP10TacsScalar"></span><span id="TACSAssembler::getElement__i.TacsScalarP.TacsScalarP.TacsScalarP.TacsScalarP"></span><span class="target" id="class_t_a_c_s_assembler_1a5e567471a64e9f74e95c461811917373"></span><a class="reference internal" href="#_CPPv411TACSElement" title="TACSElement">TACSElement</a> *<code class="sig-name descname">getElement</code><span class="sig-paren">(</span>int <em>elem</em>, TacsScalar *<em>Xpts</em> = NULL, TacsScalar *<em>vars</em> = NULL, TacsScalar *<em>dvars</em> = NULL, TacsScalar *<em>ddvars</em> = NULL<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler10getElementEiP10TacsScalarP10TacsScalarP10TacsScalarP10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the element object and the corresponding element variables</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The element object (NULL if index is out of range) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: The element index </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Xpts</span></code>: The element nodes array (may be NULL) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vars</span></code>: The element variable array (may be NULL) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvars</span></code>: The element variable time derivative array (may be NULL) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvars</span></code>: The element variable time derivative array (may be NULL) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler10getElementEiPiPPKi">
<span id="_CPPv3N13TACSAssembler10getElementEiPiPPKi"></span><span id="_CPPv2N13TACSAssembler10getElementEiPiPPKi"></span><span id="TACSAssembler::getElement__i.iP.iCPP"></span><span class="target" id="class_t_a_c_s_assembler_1ac00de5a5f804691fdbe30daf599d327e"></span><a class="reference internal" href="#_CPPv411TACSElement" title="TACSElement">TACSElement</a> *<code class="sig-name descname">getElement</code><span class="sig-paren">(</span>int <em>elem</em>, int *<em>len</em>, <em class="property">const</em> int **<em>nodes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler10getElementEiPiPPKi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the element object and the pointer to the node numbers</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The element object (NULL if index is out of range) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: The element index </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nodes</span></code>: The global node numbers </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">len</span></code>: The number of nodes for this element </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler11testElementEiiddd">
<span id="_CPPv3N13TACSAssembler11testElementEiiddd"></span><span id="_CPPv2N13TACSAssembler11testElementEiiddd"></span><span id="TACSAssembler::testElement__i.i.double.double.double"></span><span class="target" id="class_t_a_c_s_assembler_1a97ea2d110702525c4ba13a2d43bd8549"></span>void <code class="sig-name descname">testElement</code><span class="sig-paren">(</span>int <em>elemNum</em>, int <em>print_level</em>, double <em>dh</em> = 1e-6, double <em>rtol</em> = 1e-8, double <em>atol</em> = 1e-1<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler11testElementEiiddd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test the implementation of the given element number.</p>
<p>This tests the stiffness matrix and various parts of the design-sensitivities: the derivative of the determinant of the Jacobian, the derivative of the strain w.r.t. the nodal coordinates, and the state variables and the derivative of the residual w.r.t. the design variables and nodal coordiantes.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elemNum</span></code>: The local element index to test </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">print_level</span></code>: Print level to use </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dh</span></code>: Finite-difference (or complex-step) step length </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rtol</span></code>: Relative tolerance to apply </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">atol</span></code>: Absolute tolerance to apply </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler12testFunctionEP12TACSFunctiond">
<span id="_CPPv3N13TACSAssembler12testFunctionEP12TACSFunctiond"></span><span id="_CPPv2N13TACSAssembler12testFunctionEP12TACSFunctiond"></span><span id="TACSAssembler::testFunction__TACSFunctionP.double"></span><span class="target" id="class_t_a_c_s_assembler_1a6e4ecffc4777bbb9c1f7de77c2ed2228"></span>void <code class="sig-name descname">testFunction</code><span class="sig-paren">(</span>TACSFunction *<em>func</em>, double <em>dh</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler12testFunctionEP12TACSFunctiond" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test the implementation of the function.</p>
<p>This tests the state variable sensitivities and the design variable sensitivities of the function of interest. These sensitivities are computed based on a random perturbation of the input values. Note that a system of equations should be solved - or the variables should be set randomly before calling this function, otherwise this function may produce unrealistic function values.</p>
<p>Note that this function uses a central difference if the real code is compiled, and a complex step approximation if the complex version of the code is used.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">func</span></code>: The function to test </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dh</span></code>: The finite-difference or complex-step step size </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler13setNumThreadsEi">
<span id="_CPPv3N13TACSAssembler13setNumThreadsEi"></span><span id="_CPPv2N13TACSAssembler13setNumThreadsEi"></span><span id="TACSAssembler::setNumThreads__i"></span><span class="target" id="class_t_a_c_s_assembler_1aacc6f30c1bacfe1cec549b104c3a08aa"></span>void <code class="sig-name descname">setNumThreads</code><span class="sig-paren">(</span>int <em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler13setNumThreadsEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the number of threads to use in the computation</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code>: The number of threads </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler16getNumComponentsEv">
<span id="_CPPv3N13TACSAssembler16getNumComponentsEv"></span><span id="_CPPv2N13TACSAssembler16getNumComponentsEv"></span><span id="TACSAssembler::getNumComponents"></span><span class="target" id="class_t_a_c_s_assembler_1a3a04127ac2d1491d3bf79cad3be8ef0f"></span>int <code class="sig-name descname">getNumComponents</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler16getNumComponentsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine the number of components defined by elements in the <a class="reference internal" href="#class_t_a_c_s_assembler"><span class="std std-ref">TACSAssembler</span></a> object.</p>
<p>This call is collective - the number of components is obtained by a global reduction.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The number of components </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler20getElementOutputDataE11ElementTypeiPiPiPP10TacsScalar">
<span id="_CPPv3N13TACSAssembler20getElementOutputDataE11ElementTypeiPiPiPP10TacsScalar"></span><span id="_CPPv2N13TACSAssembler20getElementOutputDataE11ElementTypeiPiPiPP10TacsScalar"></span><span id="TACSAssembler::getElementOutputData__ElementType.i.iP.iP.TacsScalarPP"></span><span class="target" id="class_t_a_c_s_assembler_1ac7524de0af0fa0a30453741c9ee4175d"></span>void <code class="sig-name descname">getElementOutputData</code><span class="sig-paren">(</span>ElementType <em>elem_type</em>, int <em>write_flag</em>, int *<em>len</em>, int *<em>nvals</em>, TacsScalar **<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler20getElementOutputDataE11ElementTypeiPiPiPP10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Go through each element and get the output data for that element.</p>
<p>The data is stored point-wise with each variable stored contiguously for each new point within the connectivity list. This stores the data at a point in memory indexed by data[node*nvals]. However, fewer than 'nvals' entries may be written in this call. The remaining data may be design variable entries that are computed below.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elem_type</span></code>: The element type to match </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">write_flag</span></code>: Binary flag indicating the components to write </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">len</span></code>: The number of points (output) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nvals</span></code>: The number of values at each point (output) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code>: The data for each point for each value (output) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler15getLocalNodeNumEi">
<span id="_CPPv3N13TACSAssembler15getLocalNodeNumEi"></span><span id="_CPPv2N13TACSAssembler15getLocalNodeNumEi"></span><span id="TACSAssembler::getLocalNodeNum__i"></span><span class="target" id="class_t_a_c_s_assembler_1a625c7ffe94ae3fb2f8554b7d19a7d3bc"></span>int <code class="sig-name descname">getLocalNodeNum</code><span class="sig-paren">(</span>int <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler15getLocalNodeNumEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The following function returns a local node number based on the provided (global) TACS node number.</p>
<p>If the node number is on this processor, no search is required, however, if the node is externally owned, then a binary search is needed to determine the index into the off-processor list of nodes.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The local node number </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">node</span></code>: The global TACS node number unique across all processors </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler16getGlobalNodeNumEi">
<span id="_CPPv3N13TACSAssembler16getGlobalNodeNumEi"></span><span id="_CPPv2N13TACSAssembler16getGlobalNodeNumEi"></span><span id="TACSAssembler::getGlobalNodeNum__i"></span><span class="target" id="class_t_a_c_s_assembler_1a679a62f41537a2dde7dd42aca592ddcb"></span>int <code class="sig-name descname">getGlobalNodeNum</code><span class="sig-paren">(</span>int <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler16getGlobalNodeNumEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Given the local node number find the corresponding global TACS node number</p>
<p>This function is the inverse of the <a class="reference internal" href="#class_t_a_c_s_assembler_1a625c7ffe94ae3fb2f8554b7d19a7d3bc"><span class="std std-ref">getLocalNodeNum()</span></a> function defined above.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The global TACS node number </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">node</span></code>: The local node number </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler25computeLocalNodeToNodeCSREPPiPPii">
<span id="_CPPv3N13TACSAssembler25computeLocalNodeToNodeCSREPPiPPii"></span><span id="_CPPv2N13TACSAssembler25computeLocalNodeToNodeCSREPPiPPii"></span><span id="TACSAssembler::computeLocalNodeToNodeCSR__iPP.iPP.i"></span><span class="target" id="class_t_a_c_s_assembler_1ac706e5e8b403c94273fe4b126a65d3d0"></span>void <code class="sig-name descname">computeLocalNodeToNodeCSR</code><span class="sig-paren">(</span>int **<em>_rowp</em>, int **<em>_cols</em>, int <em>nodiag</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler25computeLocalNodeToNodeCSREPPiPPii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set up a CSR data structure pointing from local nodes to other local nodes.</p>
<p>This function works by first estimating the number of entries in each row of the matrix. This information is stored temporarily in the array rowp. After the contributions from the elements and sparse constraints are added, the preceeding elements in rowp are added such that rowp becomes the row pointer for the matrix. Note that this is an upper bound because the elements and constraints may introduce repeated variables. Next, cols is allocated corresponding to the column index for each entry. This iterates back over all elements and constraints. At this stage, rowp is treated as an array of indices, that index into the i-th row of cols[:] where the next index should be inserted. As a result, rowp must be adjusted after this operation is completed. The last step is to sort and uniquify each row of the matrix.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">_rowp</span></code>: The row pointer corresponding to CSR data structure </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cols</span></code>: The column indices for each row of the CSR data structure </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nodiag</span></code>: Flag to indicate whether to remove the diagonal matrix entry </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N13TACSAssembler23computeNodeToElementCSREPPiPPi">
<span id="_CPPv3N13TACSAssembler23computeNodeToElementCSREPPiPPi"></span><span id="_CPPv2N13TACSAssembler23computeNodeToElementCSREPPiPPi"></span><span id="TACSAssembler::computeNodeToElementCSR__iPP.iPP"></span><span class="target" id="class_t_a_c_s_assembler_1a65ac7707f4a0e063dbfa5e4859781943"></span>void <code class="sig-name descname">computeNodeToElementCSR</code><span class="sig-paren">(</span>int **<em>_nodeElem</em>, int **<em>_nodeElemIndex</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13TACSAssembler23computeNodeToElementCSREPPiPPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The following function creates a data structure that links nodes to elements - this reverses the existing data structure that links elements to nodes but keeps the original in tact.</p>
<p>The algorithm proceeds as follows:</p>
<p><ol class="arabic simple">
<li><p>The size of the arrays are determined by finding how many nodes point to each element</p></li>
<li><p>The index into the nodeElem array is determined by adding up the contributions from all previous entries.</p></li>
<li><p>The original data structure is again traversed and this time an element number is associated with each element.</p></li>
</ol>
</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">_nodeElementPtr</span></code>: Pointer into the array nodeToElements </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_nodeToElements</span></code>: Element index associated with each node </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv411TACSCreator">
<span id="_CPPv311TACSCreator"></span><span id="_CPPv211TACSCreator"></span><span id="TACSCreator"></span><span class="target" id="class_t_a_c_s_creator"></span><em class="property">class </em><code class="sig-name descname">TACSCreator</code> : <em class="property">public</em> TACSObject<a class="headerlink" href="#_CPPv411TACSCreator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The following file contains the <a class="reference internal" href="#class_t_a_c_s_creator"><span class="std std-ref">TACSCreator</span></a> object which can be used to create <a class="reference internal" href="#class_t_a_c_s_assembler"><span class="std std-ref">TACSAssembler</span></a> object for finite-element analysis.</p>
<p>This code automatically redistributes a serial mesh in parallel. It cannot handle extremely large meshes, but is useful for many moderate-scale applications.</p>
<p>The user must specify the connectivity, boundary conditions, elements, node locations and optionally any dependent nodes that are defined. The elements may be provided in a list, or a callback function can be used to create them. In the case of the callback, the function is called repeatedly for every element within the finite-element mesh (not just once per element-id number).</p>
<p>The user may wish to modify the ordering of TACS. This can be done by specifying the reordering type prior to calling createTACS().</p>
<p>The new node numbers and new element partition can be retrieved from the creator object using the getNodeNums()/getElementPartion(). Note that it is guaranteed that on each partiton, the elements will be numbered in ascending global order. This can be used to remap the distributed element order back to the original element order. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N11TACSCreator11TACSCreatorE8MPI_Commi">
<span id="_CPPv3N11TACSCreator11TACSCreatorE8MPI_Commi"></span><span id="_CPPv2N11TACSCreator11TACSCreatorE8MPI_Commi"></span><span id="TACSCreator::TACSCreator__MPI_Comm.i"></span><span class="target" id="class_t_a_c_s_creator_1aa974bff0902b367bb89691dacc9d6bc0"></span><code class="sig-name descname">TACSCreator</code><span class="sig-paren">(</span>MPI_Comm <em>comm</em>, int <em>_vars_per_node</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSCreator11TACSCreatorE8MPI_Commi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate the <a class="reference internal" href="#class_t_a_c_s_creator"><span class="std std-ref">TACSCreator</span></a> object</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">_comm</span></code>: The MPI_Comm object </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_vars_per_node</span></code>: The number of variables at each node </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSCreatorD0Ev">
<span id="_CPPv3N11TACSCreatorD0Ev"></span><span id="_CPPv2N11TACSCreatorD0Ev"></span><span id="TACSCreator::~TACSCreator"></span><span class="target" id="class_t_a_c_s_creator_1ac04bf77159555740833a74c4deb7dcd1"></span><code class="sig-name descname">~TACSCreator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSCreatorD0Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Deallocate the <a class="reference internal" href="#class_t_a_c_s_creator"><span class="std std-ref">TACSCreator</span></a> object </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv411TACSElement">
<span id="_CPPv311TACSElement"></span><span id="_CPPv211TACSElement"></span><span id="TACSElement"></span><span class="target" id="class_t_a_c_s_element"></span><em class="property">class </em><code class="sig-name descname">TACSElement</code> : <em class="property">public</em> TACSObject<a class="headerlink" href="#_CPPv411TACSElement" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Subclassed by MITC3, MITC9, PoissonQuad&lt; order &gt;, PSQuadHeatFluxTraction&lt; order &gt;, PSQuadHeatSourceSink&lt; order &gt;, PSQuadThermoTraction&lt; order &gt;, PSQuadTraction&lt; order &gt;, TACS2DElement&lt; NUM_NODES &gt;, TACS2DElement&lt; 6 &gt;, TACS2DElement&lt; order *order &gt;, TACS3DBoundingTraction&lt; order &gt;, TACS3DElement&lt; NUM_NODES &gt;, TACS3DElement&lt; order *order *order &gt;, TACS3DHeatFluxTraction&lt; order &gt;, TACS3DHeatSourceSink&lt; order &gt;, TACS3DNormalHeatFluxTraction&lt; order &gt;, TACS3DPressureTraction&lt; order &gt;, TACS3DThermoPressureTraction&lt; order &gt;, TACS3DThermoTraction&lt; order &gt;, TACS3DTraction&lt; order &gt;, TACSAverageConstraint, TACSConvectiveTraction2D, TACSConvectiveTraction3D, TACSElement2D, TACSElement3D, TACSFixedConstraint, TACSMixedInterpElement2D, TACSMotionDriver, TACSRevoluteConstraint, TACSRevoluteDriver, TACSRigidBody, TACSRigidLink, TACSShell, TACSShellPressure&lt; order &gt;, TACSShellTraction&lt; order &gt;, TACSSphericalConstraint, TACSTraction2D, TACSTraction3D, ThermoQuad, ThermoSolid</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N11TACSElement15setComponentNumEi">
<span id="_CPPv3N11TACSElement15setComponentNumEi"></span><span id="_CPPv2N11TACSElement15setComponentNumEi"></span><span id="TACSElement::setComponentNum__i"></span><span class="target" id="class_t_a_c_s_element_1a78ffb3cd898c2e28b2ef8c9fe65bb3f7"></span>void <code class="sig-name descname">setComponentNum</code><span class="sig-paren">(</span>int <em>comp_num</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement15setComponentNumEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the component number for this element.</p>
<p>The component number can be used to identify groups of elements for visualization purposes</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">comp_num</span></code>: The component number assigned to the element </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement15getComponentNumEv">
<span id="_CPPv3N11TACSElement15getComponentNumEv"></span><span id="_CPPv2N11TACSElement15getComponentNumEv"></span><span id="TACSElement::getComponentNum"></span><span class="target" id="class_t_a_c_s_element_1a880723086deb5fe74e85a9219f18bdb5"></span>int <code class="sig-name descname">getComponentNum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement15getComponentNumEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the component number for this element</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The component number for the element </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement13getObjectNameEv">
<span id="_CPPv3N11TACSElement13getObjectNameEv"></span><span id="_CPPv2N11TACSElement13getObjectNameEv"></span><span id="TACSElement::getObjectName"></span><span class="target" id="class_t_a_c_s_element_1aaafa7109cf4e2573283b75fdca297c0f"></span><em class="property">const</em> char *<code class="sig-name descname">getObjectName</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement13getObjectNameEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get a string representation of the element name</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The name of the element </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement14getVarsPerNodeEv">
<span id="_CPPv3N11TACSElement14getVarsPerNodeEv"></span><span id="_CPPv2N11TACSElement14getVarsPerNodeEv"></span><span id="TACSElement::getVarsPerNode"></span><span class="target" id="class_t_a_c_s_element_1a687cc7feadc645e731d72691ffb16077"></span><em class="property">virtual</em> int <code class="sig-name descname">getVarsPerNode</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N11TACSElement14getVarsPerNodeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the number of degrees of freedom per node for this element</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The number of degrees of freedom per node </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement11getNumNodesEv">
<span id="_CPPv3N11TACSElement11getNumNodesEv"></span><span id="_CPPv2N11TACSElement11getNumNodesEv"></span><span id="TACSElement::getNumNodes"></span><span class="target" id="class_t_a_c_s_element_1a88c74e1e9714c4505fd581c6498aa0bd"></span><em class="property">virtual</em> int <code class="sig-name descname">getNumNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N11TACSElement11getNumNodesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the number of nodes associated with this element</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The number of nodes for this element </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement15getNumVariablesEv">
<span id="_CPPv3N11TACSElement15getNumVariablesEv"></span><span id="_CPPv2N11TACSElement15getNumVariablesEv"></span><span id="TACSElement::getNumVariables"></span><span class="target" id="class_t_a_c_s_element_1a7ccc967a4c393bd8b46337b3f9de38ab"></span>int <code class="sig-name descname">getNumVariables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement15getNumVariablesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the number of variables owned by the element </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement18getMultiplierIndexEv">
<span id="_CPPv3N11TACSElement18getMultiplierIndexEv"></span><span id="_CPPv2N11TACSElement18getMultiplierIndexEv"></span><span id="TACSElement::getMultiplierIndex"></span><span class="target" id="class_t_a_c_s_element_1adce717079ee4d10d942690dc0143420e"></span><em class="property">virtual</em> int <code class="sig-name descname">getMultiplierIndex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement18getMultiplierIndexEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the node index where a Lagrange multiplier is defined.</p>
<p>A negative index indicates that no multiplier is defined. The index is relative to the ordering in the element.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Index of a Lagrange multiplier node </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement15getElementBasisEv">
<span id="_CPPv3N11TACSElement15getElementBasisEv"></span><span id="_CPPv2N11TACSElement15getElementBasisEv"></span><span id="TACSElement::getElementBasis"></span><span class="target" id="class_t_a_c_s_element_1a9571d424d45e7c2ef4aef6137588a925"></span><em class="property">virtual</em> TACSElementBasis *<code class="sig-name descname">getElementBasis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement15getElementBasisEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the element basis class</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The TACSElementBasis class associated with this element. Possibly NULL. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement15getElementModelEv">
<span id="_CPPv3N11TACSElement15getElementModelEv"></span><span id="_CPPv2N11TACSElement15getElementModelEv"></span><span id="TACSElement::getElementModel"></span><span class="target" id="class_t_a_c_s_element_1a12cfdb4ebd8101ba8aff8ad1946e7f21"></span><em class="property">virtual</em> TACSElementModel *<code class="sig-name descname">getElementModel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement15getElementModelEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the element model class</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The TACSElementModel class associated with this element. Possibly NULL. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement13getLayoutTypeEv">
<span id="_CPPv3N11TACSElement13getLayoutTypeEv"></span><span id="_CPPv2N11TACSElement13getLayoutTypeEv"></span><span id="TACSElement::getLayoutType"></span><span class="target" id="class_t_a_c_s_element_1ad61a35133dd6c00a17f21a29339e402b"></span><em class="property">virtual</em> ElementLayout <code class="sig-name descname">getLayoutType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement13getLayoutTypeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the type of element layout for visualization</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The layout type for this element </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement20getDesignVarsPerNodeEv">
<span id="_CPPv3N11TACSElement20getDesignVarsPerNodeEv"></span><span id="_CPPv2N11TACSElement20getDesignVarsPerNodeEv"></span><span id="TACSElement::getDesignVarsPerNode"></span><span class="target" id="class_t_a_c_s_element_1ac4b36c09afe3cc3bcc29b29d3aed2cf6"></span><em class="property">virtual</em> int <code class="sig-name descname">getDesignVarsPerNode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement20getDesignVarsPerNodeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the number of design variables per node.</p>
<p>The value defaults to one, unless over-ridden by the model </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement16getDesignVarNumsEiiA_i">
<span id="_CPPv3N11TACSElement16getDesignVarNumsEiiA_i"></span><span id="_CPPv2N11TACSElement16getDesignVarNumsEiiA_i"></span><span id="TACSElement::getDesignVarNums__i.i.iA"></span><span class="target" id="class_t_a_c_s_element_1a11ce9bb5b942ed801b8d936c4476610f"></span><em class="property">virtual</em> int <code class="sig-name descname">getDesignVarNums</code><span class="sig-paren">(</span>int <em>elemIndex</em>, int <em>dvLen</em>, int <em>dvNums</em>[]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement16getDesignVarNumsEiiA_i" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve the global design variable numbers associated with this element</p>
<p>Note when the dvNums argument is NULL, then the result is a query on the number of design variables and the array is not set.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The number of design variable numbers defined by the element </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dvLen</span></code>: The length of the array dvNums </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvNums</span></code>: An array of the design variable numbers for this element </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement13setDesignVarsEiiA_K10TacsScalar">
<span id="_CPPv3N11TACSElement13setDesignVarsEiiA_K10TacsScalar"></span><span id="_CPPv2N11TACSElement13setDesignVarsEiiA_K10TacsScalar"></span><span id="TACSElement::setDesignVars__i.i.TacsScalarCA"></span><span class="target" id="class_t_a_c_s_element_1aa3942ab96880065e4b9ec70386ba77a2"></span><em class="property">virtual</em> int <code class="sig-name descname">setDesignVars</code><span class="sig-paren">(</span>int <em>elemIndex</em>, int <em>dvLen</em>, <em class="property">const</em> TacsScalar <em>dvs</em>[]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement13setDesignVarsEiiA_K10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the element design variables from the design vector</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The number of design variable numbers defined by the element </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elemIndex</span></code>: The local element index </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvLen</span></code>: The length of the design array </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvs</span></code>: The design variable values </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement13getDesignVarsEiiA_10TacsScalar">
<span id="_CPPv3N11TACSElement13getDesignVarsEiiA_10TacsScalar"></span><span id="_CPPv2N11TACSElement13getDesignVarsEiiA_10TacsScalar"></span><span id="TACSElement::getDesignVars__i.i.TacsScalarA"></span><span class="target" id="class_t_a_c_s_element_1a95e7d00511079cede993f3963808c15e"></span><em class="property">virtual</em> int <code class="sig-name descname">getDesignVars</code><span class="sig-paren">(</span>int <em>elemIndex</em>, int <em>dvLen</em>, TacsScalar <em>dvs</em>[]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement13getDesignVarsEiiA_10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the element design variables values</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The number of design variable numbers defined by the element </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elemIndex</span></code>: The local element index </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvLen</span></code>: The length of the design array </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvs</span></code>: The design variable values </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement17getDesignVarRangeEiiA_10TacsScalarA_10TacsScalar">
<span id="_CPPv3N11TACSElement17getDesignVarRangeEiiA_10TacsScalarA_10TacsScalar"></span><span id="_CPPv2N11TACSElement17getDesignVarRangeEiiA_10TacsScalarA_10TacsScalar"></span><span id="TACSElement::getDesignVarRange__i.i.TacsScalarA.TacsScalarA"></span><span class="target" id="class_t_a_c_s_element_1a602c07eebdebcdecf864ea5474fd0440"></span><em class="property">virtual</em> int <code class="sig-name descname">getDesignVarRange</code><span class="sig-paren">(</span>int <em>elemIndex</em>, int <em>dvLen</em>, TacsScalar <em>lowerBound</em>[], TacsScalar <em>upperBound</em>[]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement17getDesignVarRangeEiiA_10TacsScalarA_10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the lower and upper bounds for the design variable values</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The number of design variable numbers defined by the element </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elemIndex</span></code>: The local element index </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvLen</span></code>: The length of the design array </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lowerBound</span></code>: The design variable lower bounds </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lowerBound</span></code>: The design variable upper bounds </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement17getInitConditionsEiA_K10TacsScalarA_10TacsScalarA_10TacsScalarA_10TacsScalar">
<span id="_CPPv3N11TACSElement17getInitConditionsEiA_K10TacsScalarA_10TacsScalarA_10TacsScalarA_10TacsScalar"></span><span id="_CPPv2N11TACSElement17getInitConditionsEiA_K10TacsScalarA_10TacsScalarA_10TacsScalarA_10TacsScalar"></span><span id="TACSElement::getInitConditions__i.TacsScalarCA.TacsScalarA.TacsScalarA.TacsScalarA"></span><span class="target" id="class_t_a_c_s_element_1ae12feea8ed75f2b2a790bc4946ad29e4"></span><em class="property">virtual</em> void <code class="sig-name descname">getInitConditions</code><span class="sig-paren">(</span>int <em>elemIndex</em>, <em class="property">const</em> TacsScalar <em>Xpts</em>[], TacsScalar <em>vars</em>[], TacsScalar <em>dvars</em>[], TacsScalar <em>ddvars</em>[]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement17getInitConditionsEiA_K10TacsScalarA_10TacsScalarA_10TacsScalarA_10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve the initial conditions for time-dependent analysis</p>
<p>By default, the initial displacements, velocities and accelerations are zero.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elemIndex</span></code>: The local element index </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Xpts</span></code>: The element node locations </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vars</span></code>: The values of the element degrees of freedom </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvars</span></code>: The first time derivative of the element DOF </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ddvars</span></code>: The second time derivative of the element DOF </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement29addInitConditionAdjResProductEiA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalariA_10TacsScalar">
<span id="_CPPv3N11TACSElement29addInitConditionAdjResProductEiA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalariA_10TacsScalar"></span><span id="_CPPv2N11TACSElement29addInitConditionAdjResProductEiA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalariA_10TacsScalar"></span><span id="TACSElement::addInitConditionAdjResProduct__i.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarCA.i.TacsScalarA"></span><span class="target" id="class_t_a_c_s_element_1a029449bd585703d6a5c6995bb2b6fb07"></span><em class="property">virtual</em> void <code class="sig-name descname">addInitConditionAdjResProduct</code><span class="sig-paren">(</span>int <em>elemIndex</em>, <em class="property">const</em> TacsScalar <em>Xpts</em>[], <em class="property">const</em> TacsScalar <em>adjVars</em>[], <em class="property">const</em> TacsScalar <em>adjDVars</em>[], <em class="property">const</em> TacsScalar <em>adjDDVars</em>[], int <em>dvLen</em>, TacsScalar <em>fdvSens</em>[]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement29addInitConditionAdjResProductEiA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalariA_10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add the contributions to the derivative from the initial conditions</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elemIndex</span></code>: The local element index </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Xpts</span></code>: The element node locations </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">adjVars</span></code>: The values of the element adjoint </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">adjDVars</span></code>: The adjoint of the first time derivatives </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">adjDDVars</span></code>: The adjoint of the first time derivatives </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ddvars</span></code>: The second time derivative of the element DOF </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvLen</span></code>: The length of the design vector </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement32getInitConditionAdjResXptProductEiA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar">
<span id="_CPPv3N11TACSElement32getInitConditionAdjResXptProductEiA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar"></span><span id="_CPPv2N11TACSElement32getInitConditionAdjResXptProductEiA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar"></span><span id="TACSElement::getInitConditionAdjResXptProduct__i.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarA"></span><span class="target" id="class_t_a_c_s_element_1a512f81e258f1cc4edbb8d66611b1621d"></span><em class="property">virtual</em> void <code class="sig-name descname">getInitConditionAdjResXptProduct</code><span class="sig-paren">(</span>int <em>elemIndex</em>, <em class="property">const</em> TacsScalar <em>Xpts</em>[], <em class="property">const</em> TacsScalar <em>adjVars</em>[], <em class="property">const</em> TacsScalar <em>adjDVars</em>[], <em class="property">const</em> TacsScalar <em>adjDDVars</em>[], TacsScalar <em>fXptSens</em>[]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement32getInitConditionAdjResXptProductEiA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the contribution to the derivatives of the initial conditions w.r.t. the node locations</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elemIndex</span></code>: The local element index </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Xpts</span></code>: The element node locations </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">adjVars</span></code>: The values of the element adjoint </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">adjDVars</span></code>: The adjoint of the first time derivatives </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">adjDDVars</span></code>: The adjoint of the first time derivatives </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fXptSens</span></code>: Derivative w.r.t. the node locations </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement15computeEnergiesEidA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarP10TacsScalarP10TacsScalar">
<span id="_CPPv3N11TACSElement15computeEnergiesEidA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarP10TacsScalarP10TacsScalar"></span><span id="_CPPv2N11TACSElement15computeEnergiesEidA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarP10TacsScalarP10TacsScalar"></span><span id="TACSElement::computeEnergies__i.double.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarP.TacsScalarP"></span><span class="target" id="class_t_a_c_s_element_1aa3b5117593416d50aee7ad0ff147b5be"></span><em class="property">virtual</em> void <code class="sig-name descname">computeEnergies</code><span class="sig-paren">(</span>int <em>elemIndex</em>, double <em>time</em>, <em class="property">const</em> TacsScalar <em>Xpts</em>[], <em class="property">const</em> TacsScalar <em>vars</em>[], <em class="property">const</em> TacsScalar <em>dvars</em>[], TacsScalar *<em>Te</em>, TacsScalar *<em>Pe</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement15computeEnergiesEidA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarP10TacsScalarP10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute the kinetic and potential energy within the element.</p>
<p>This can be used to evaluate the Hamiltonian and test whether the element satisfies the Lagrangian equations of motion.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elemIndex</span></code>: The local element index </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time</span></code>: The simulation time </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Xpts</span></code>: The element node locations </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vars</span></code>: The values of the element degrees of freedom </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvars</span></code>: The first time derivative of the element DOF </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Te</span></code>: The kinetic energy contributed by this element </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Pe</span></code>: the potential energy contributed by this element </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement11addResidualEidA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar">
<span id="_CPPv3N11TACSElement11addResidualEidA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar"></span><span id="_CPPv2N11TACSElement11addResidualEidA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar"></span><span id="TACSElement::addResidual__i.double.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarA"></span><span class="target" id="class_t_a_c_s_element_1acea8ee7a4d57ca22b5276f01051c08f3"></span><em class="property">virtual</em> void <code class="sig-name descname">addResidual</code><span class="sig-paren">(</span>int <em>elemIndex</em>, double <em>time</em>, <em class="property">const</em> TacsScalar <em>Xpts</em>[], <em class="property">const</em> TacsScalar <em>vars</em>[], <em class="property">const</em> TacsScalar <em>dvars</em>[], <em class="property">const</em> TacsScalar <em>ddvars</em>[], TacsScalar <em>res</em>[]<span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N11TACSElement11addResidualEidA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add the contribution from this element to the residual.</p>
<p>Note that this simply adds, and does not over-write the residual so that multiple contributions can be computed.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elemIndex</span></code>: The local element index </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time</span></code>: The simulation time </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Xpts</span></code>: The element node locations </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vars</span></code>: The values of the element degrees of freedom </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvars</span></code>: The first time derivative of the element DOF </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ddvars</span></code>: The second time derivative of the element DOF </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">res</span></code>: The element residual input/output </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement11addJacobianEid10TacsScalar10TacsScalar10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalarA_10TacsScalar">
<span id="_CPPv3N11TACSElement11addJacobianEid10TacsScalar10TacsScalar10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalarA_10TacsScalar"></span><span id="_CPPv2N11TACSElement11addJacobianEid10TacsScalar10TacsScalar10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalarA_10TacsScalar"></span><span id="TACSElement::addJacobian__i.double.TacsScalar.TacsScalar.TacsScalar.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarA.TacsScalarA"></span><span class="target" id="class_t_a_c_s_element_1a05c73705e2d320185a31521feadc848c"></span>void <code class="sig-name descname">addJacobian</code><span class="sig-paren">(</span>int <em>elemIndex</em>, double <em>time</em>, TacsScalar <em>alpha</em>, TacsScalar <em>beta</em>, TacsScalar <em>gamma</em>, <em class="property">const</em> TacsScalar <em>Xpts</em>[], <em class="property">const</em> TacsScalar <em>vars</em>[], <em class="property">const</em> TacsScalar <em>dvars</em>[], <em class="property">const</em> TacsScalar <em>ddvars</em>[], TacsScalar <em>res</em>[], TacsScalar <em>mat</em>[]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement11addJacobianEid10TacsScalar10TacsScalar10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalarA_10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add the contribution from this element to the residual and Jacobian.</p>
<p>Note that this simply adds, and does not over-write the Jacobian so that multiple contributions can be computed.</p>
<p>The Jacobian contribution consists of a linear combination of the Jacobians with respect to the variables, and their first and second time derivatives as follows:</p>
<p>mat += alpha*d(res)/d(vars) + beta*d(res)/d(dvars) + gamma*d(res)/d(ddvars)</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elemIndex</span></code>: The local element index </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time</span></code>: The simulation time </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">alpha</span></code>: The coefficient for the DOF Jacobian </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">beta</span></code>: The coefficient for the first time derivative DOF Jacobian </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gamma</span></code>: The coefficient for the second time derivative DOF Jacobian </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Xpts</span></code>: The element node locations </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vars</span></code>: The values of the element degrees of freedom </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvars</span></code>: The first time derivative of the element DOF </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ddvars</span></code>: The second time derivative of the element DOF </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">res</span></code>: The element residual input/output </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mat</span></code>: The element Jacobian input/output </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement16addAdjResProductEid10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalariA_10TacsScalar">
<span id="_CPPv3N11TACSElement16addAdjResProductEid10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalariA_10TacsScalar"></span><span id="_CPPv2N11TACSElement16addAdjResProductEid10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalariA_10TacsScalar"></span><span id="TACSElement::addAdjResProduct__i.double.TacsScalar.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarCA.i.TacsScalarA"></span><span class="target" id="class_t_a_c_s_element_1a36738fd80f2a104c5f573d7c357a94e1"></span><em class="property">virtual</em> void <code class="sig-name descname">addAdjResProduct</code><span class="sig-paren">(</span>int <em>elemIndex</em>, double <em>time</em>, TacsScalar <em>scale</em>, <em class="property">const</em> TacsScalar <em>psi</em>[], <em class="property">const</em> TacsScalar <em>Xpts</em>[], <em class="property">const</em> TacsScalar <em>vars</em>[], <em class="property">const</em> TacsScalar <em>dvars</em>[], <em class="property">const</em> TacsScalar <em>ddvars</em>[], int <em>dvLen</em>, TacsScalar <em>dfdx</em>[]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement16addAdjResProductEid10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalariA_10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add the derivative of the adjoint-residual product to the output vector</p>
<p>This adds the contribution scaled by an input factor as follows:</p>
<p>dvSens += scale*d(psi^{T}*(res))/dx</p>
<p>By default the code is not implemented, but is not required so that analysis can be performed. Correct derivatives require a specific implementation.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elemIndex</span></code>: The local element index </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time</span></code>: The simulation time </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">scale</span></code>: The coefficient for the derivative result </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">psi</span></code>: The element adjoint variables </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Xpts</span></code>: The element node locations </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vars</span></code>: The values of the element degrees of freedom </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvars</span></code>: The first time derivative of the element DOF </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ddvars</span></code>: The second time derivative of the element DOF </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvLen</span></code>: The length of the design variable vector </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvSens</span></code>: The derivative vector </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement19addAdjResXptProductEid10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar">
<span id="_CPPv3N11TACSElement19addAdjResXptProductEid10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar"></span><span id="_CPPv2N11TACSElement19addAdjResXptProductEid10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar"></span><span id="TACSElement::addAdjResXptProduct__i.double.TacsScalar.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarA"></span><span class="target" id="class_t_a_c_s_element_1af08cb640e999de95dcf35895616236d8"></span><em class="property">virtual</em> void <code class="sig-name descname">addAdjResXptProduct</code><span class="sig-paren">(</span>int <em>elemIndex</em>, double <em>time</em>, TacsScalar <em>scale</em>, <em class="property">const</em> TacsScalar <em>psi</em>[], <em class="property">const</em> TacsScalar <em>Xpts</em>[], <em class="property">const</em> TacsScalar <em>vars</em>[], <em class="property">const</em> TacsScalar <em>dvars</em>[], <em class="property">const</em> TacsScalar <em>ddvars</em>[], TacsScalar <em>fXptSens</em>[]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement19addAdjResXptProductEid10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add the derivative of the adjoint-residual product to the output vector</p>
<p>This adds the contribution scaled by an input factor as follows:</p>
<p>dvSens += scale*d(psi^{T}*(res))/d(Xpts)</p>
<p>By default the code is not implemented, but is not required so that analysis can be performed. Correct derivatives require a specific implementation.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elemIndex</span></code>: The local element index </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time</span></code>: The simulation time </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">scale</span></code>: The coefficient for the derivative result </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">psi</span></code>: The element adjoint variables </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Xpts</span></code>: The element node locations </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vars</span></code>: The values of the element degrees of freedom </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvars</span></code>: The first time derivative of the element DOF </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ddvars</span></code>: The second time derivative of the element DOF </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvLen</span></code>: The length of the design variable vector </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvSens</span></code>: The derivative vector </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement10getMatTypeE17ElementMatrixTypeidA_K10TacsScalarA_K10TacsScalarA_10TacsScalar">
<span id="_CPPv3N11TACSElement10getMatTypeE17ElementMatrixTypeidA_K10TacsScalarA_K10TacsScalarA_10TacsScalar"></span><span id="_CPPv2N11TACSElement10getMatTypeE17ElementMatrixTypeidA_K10TacsScalarA_K10TacsScalarA_10TacsScalar"></span><span id="TACSElement::getMatType__ElementMatrixType.i.double.TacsScalarCA.TacsScalarCA.TacsScalarA"></span><span class="target" id="class_t_a_c_s_element_1acb18edbfe33ecf270051de7c85cf54a3"></span><em class="property">virtual</em> void <code class="sig-name descname">getMatType</code><span class="sig-paren">(</span>ElementMatrixType <em>matType</em>, int <em>elemIndex</em>, double <em>time</em>, <em class="property">const</em> TacsScalar <em>Xpts</em>[], <em class="property">const</em> TacsScalar <em>vars</em>[], TacsScalar <em>mat</em>[]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement10getMatTypeE17ElementMatrixTypeidA_K10TacsScalarA_K10TacsScalarA_10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute a specific type of element matrix (mass, stiffness, geometric stiffness, etc.)</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elemIndex</span></code>: The local element index </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">matType</span></code>: The type of element matrix to compute </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Xpts</span></code>: The element node locations </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vars</span></code>: The values of element degrees of freedom </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mat</span></code>: The element matrix output </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement24addMatDVSensInnerProductE17ElementMatrixTypeid10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalariA_10TacsScalar">
<span id="_CPPv3N11TACSElement24addMatDVSensInnerProductE17ElementMatrixTypeid10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalariA_10TacsScalar"></span><span id="_CPPv2N11TACSElement24addMatDVSensInnerProductE17ElementMatrixTypeid10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalariA_10TacsScalar"></span><span id="TACSElement::addMatDVSensInnerProduct__ElementMatrixType.i.double.TacsScalar.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarCA.i.TacsScalarA"></span><span class="target" id="class_t_a_c_s_element_1a852d9fc62592af2d4d4c11cd7c36f2e9"></span><em class="property">virtual</em> void <code class="sig-name descname">addMatDVSensInnerProduct</code><span class="sig-paren">(</span>ElementMatrixType <em>matType</em>, int <em>elemIndex</em>, double <em>time</em>, TacsScalar <em>scale</em>, <em class="property">const</em> TacsScalar <em>psi</em>[], <em class="property">const</em> TacsScalar <em>phi</em>[], <em class="property">const</em> TacsScalar <em>Xpts</em>[], <em class="property">const</em> TacsScalar <em>vars</em>[], int <em>dvLen</em>, TacsScalar <em>dfdx</em>[]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement24addMatDVSensInnerProductE17ElementMatrixTypeid10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalariA_10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add the derivative of the product of a specific matrix w.r.t. the design variables</p>
<p>dvSens += scale*d(psi^{T}*(mat)*phi)/d(x)</p>
<p>where mat is computed via the <a class="reference internal" href="#class_t_a_c_s_element_1acb18edbfe33ecf270051de7c85cf54a3"><span class="std std-ref">getMatType()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">matType</span></code>: The type of element matrix to compute </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elemIndex</span></code>: The local element index </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time</span></code>: The simulation time </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">scale</span></code>: The scalar value that multiplies the derivative </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">psi</span></code>: The left-hand vector </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">phi</span></code>: The right-hand vector </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Xpts</span></code>: The element node locations </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vars</span></code>: The values of element degrees of freedom </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvLen</span></code>: The length of the element derivative </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfdx</span></code>: The element derivative </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement24getMatSVSensInnerProductE17ElementMatrixTypeidA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar">
<span id="_CPPv3N11TACSElement24getMatSVSensInnerProductE17ElementMatrixTypeidA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar"></span><span id="_CPPv2N11TACSElement24getMatSVSensInnerProductE17ElementMatrixTypeidA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar"></span><span id="TACSElement::getMatSVSensInnerProduct__ElementMatrixType.i.double.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarA"></span><span class="target" id="class_t_a_c_s_element_1ad0ec36c0a6f05110e9310ed783e85b30"></span><em class="property">virtual</em> void <code class="sig-name descname">getMatSVSensInnerProduct</code><span class="sig-paren">(</span>ElementMatrixType <em>matType</em>, int <em>elemIndex</em>, double <em>time</em>, <em class="property">const</em> TacsScalar <em>psi</em>[], <em class="property">const</em> TacsScalar <em>phi</em>[], <em class="property">const</em> TacsScalar <em>Xpts</em>[], <em class="property">const</em> TacsScalar <em>vars</em>[], TacsScalar <em>dfdu</em>[]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement24getMatSVSensInnerProductE17ElementMatrixTypeidA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute the derivative of the product of a specific matrix w.r.t. the input variables (vars).</p>
<p>dvSens = d(psi^{T}*(mat)*phi)/d(vars)</p>
<p>where mat is computed via the <a class="reference internal" href="#class_t_a_c_s_element_1acb18edbfe33ecf270051de7c85cf54a3"><span class="std std-ref">getMatType()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">matType</span></code>: The type of element matrix to compute </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elemIndex</span></code>: The local element index </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time</span></code>: The simulation time </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">psi</span></code>: The left-hand vector </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">phi</span></code>: The right-hand vector </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Xpts</span></code>: The element node locations </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vars</span></code>: The values of element degrees of freedom </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfdu</span></code>: The residual output The element matrix output </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement17evalPointQuantityEiidiA_dA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarP10TacsScalar">
<span id="_CPPv3N11TACSElement17evalPointQuantityEiidiA_dA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarP10TacsScalar"></span><span id="_CPPv2N11TACSElement17evalPointQuantityEiidiA_dA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarP10TacsScalar"></span><span id="TACSElement::evalPointQuantity__i.i.double.i.doubleA.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarP"></span><span class="target" id="class_t_a_c_s_element_1a70fc3657673a75789289d3b38ac5e05e"></span><em class="property">virtual</em> int <code class="sig-name descname">evalPointQuantity</code><span class="sig-paren">(</span>int <em>elemIndex</em>, int <em>quantityType</em>, double <em>time</em>, int <em>n</em>, double <em>pt</em>[], <em class="property">const</em> TacsScalar <em>Xpts</em>[], <em class="property">const</em> TacsScalar <em>vars</em>[], <em class="property">const</em> TacsScalar <em>dvars</em>[], <em class="property">const</em> TacsScalar <em>ddvars</em>[], TacsScalar *<em>quantity</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement17evalPointQuantityEiidiA_dA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarP10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Evaluate a point-wise quantity of interest.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Integer indicating the number of defined quantities </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elemIndex</span></code>: The index of the element </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">quantityType</span></code>: The integer indicating the pointwise quantity </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time</span></code>: The simulation time </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code>: The quadrature point index </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pt</span></code>: The quadrature point </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Xpts</span></code>: The element node locations </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vars</span></code>: The values of the element degrees of freedom </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvars</span></code>: The first time derivative of the element DOF </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ddvars</span></code>: The second time derivative of the element DOF </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">quantity</span></code>: The output quantity of interest </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement22addPointQuantityDVSensEiid10TacsScalariA_dA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalariA_10TacsScalar">
<span id="_CPPv3N11TACSElement22addPointQuantityDVSensEiid10TacsScalariA_dA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalariA_10TacsScalar"></span><span id="_CPPv2N11TACSElement22addPointQuantityDVSensEiid10TacsScalariA_dA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalariA_10TacsScalar"></span><span id="TACSElement::addPointQuantityDVSens__i.i.double.TacsScalar.i.doubleA.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarCA.i.TacsScalarA"></span><span class="target" id="class_t_a_c_s_element_1ae349d58004757331589e59efcefab4ce"></span><em class="property">virtual</em> void <code class="sig-name descname">addPointQuantityDVSens</code><span class="sig-paren">(</span>int <em>elemIndex</em>, int <em>quantityType</em>, double <em>time</em>, TacsScalar <em>scale</em>, int <em>n</em>, double <em>pt</em>[], <em class="property">const</em> TacsScalar <em>Xpts</em>[], <em class="property">const</em> TacsScalar <em>vars</em>[], <em class="property">const</em> TacsScalar <em>dvars</em>[], <em class="property">const</em> TacsScalar <em>ddvars</em>[], <em class="property">const</em> TacsScalar <em>dfdq</em>[], int <em>dvLen</em>, TacsScalar <em>dfdx</em>[]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement22addPointQuantityDVSensEiid10TacsScalariA_dA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalariA_10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add the derivative of the point quantity w.r.t. the design variables</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elemIndex</span></code>: The index of the element </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">quantityType</span></code>: The integer indicating the pointwise quantity </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time</span></code>: The simulation time </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code>: The quadrature point index </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pt</span></code>: The quadrature point </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Xpts</span></code>: The element node locations </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vars</span></code>: The values of the element degrees of freedom </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvars</span></code>: The first time derivative of the element DOF </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ddvars</span></code>: The second time derivative of the element DOF </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvLen</span></code>: The length of the design array </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fdvSens</span></code>: The derivative array </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement22addPointQuantitySVSensEiid10TacsScalar10TacsScalar10TacsScalariA_dA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar">
<span id="_CPPv3N11TACSElement22addPointQuantitySVSensEiid10TacsScalar10TacsScalar10TacsScalariA_dA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar"></span><span id="_CPPv2N11TACSElement22addPointQuantitySVSensEiid10TacsScalar10TacsScalar10TacsScalariA_dA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar"></span><span id="TACSElement::addPointQuantitySVSens__i.i.double.TacsScalar.TacsScalar.TacsScalar.i.doubleA.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarA"></span><span class="target" id="class_t_a_c_s_element_1ac18dc87683e5d7590617173291d6e22f"></span><em class="property">virtual</em> void <code class="sig-name descname">addPointQuantitySVSens</code><span class="sig-paren">(</span>int <em>elemIndex</em>, int <em>quantityType</em>, double <em>time</em>, TacsScalar <em>alpha</em>, TacsScalar <em>beta</em>, TacsScalar <em>gamma</em>, int <em>n</em>, double <em>pt</em>[], <em class="property">const</em> TacsScalar <em>Xpts</em>[], <em class="property">const</em> TacsScalar <em>vars</em>[], <em class="property">const</em> TacsScalar <em>dvars</em>[], <em class="property">const</em> TacsScalar <em>ddvars</em>[], <em class="property">const</em> TacsScalar <em>dfdq</em>[], TacsScalar <em>dfdu</em>[]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement22addPointQuantitySVSensEiid10TacsScalar10TacsScalar10TacsScalariA_dA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add the derivative of the point quantity w.r.t. the state variables</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elemIndex</span></code>: The index of the element </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time</span></code>: The simulation time </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">quantityType</span></code>: The integer indicating the pointwise quantity </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">alpha</span></code>: The coefficient for the state variables </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">beta</span></code>: The coefficient for the first time derivatives </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gamma</span></code>: The coefficient for the second time derivatives </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code>: The quadrature point index </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pt</span></code>: The quadrature point </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Xpts</span></code>: The element node locations </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vars</span></code>: The values of the element degrees of freedom </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvars</span></code>: The first time derivative of the element DOF </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ddvars</span></code>: The second time derivative of the element DOF </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvLen</span></code>: The length of the design array </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfdu</span></code>: The derivative of the quantity w.r.t. state variables </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement23addPointQuantityXptSensEiid10TacsScalariA_dA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar">
<span id="_CPPv3N11TACSElement23addPointQuantityXptSensEiid10TacsScalariA_dA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar"></span><span id="_CPPv2N11TACSElement23addPointQuantityXptSensEiid10TacsScalariA_dA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar"></span><span id="TACSElement::addPointQuantityXptSens__i.i.double.TacsScalar.i.doubleA.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarA"></span><span class="target" id="class_t_a_c_s_element_1ab6fd53c939ce12d637f6e7aee720052f"></span><em class="property">virtual</em> void <code class="sig-name descname">addPointQuantityXptSens</code><span class="sig-paren">(</span>int <em>elemIndex</em>, int <em>quantityType</em>, double <em>time</em>, TacsScalar <em>scale</em>, int <em>n</em>, double <em>pt</em>[], <em class="property">const</em> TacsScalar <em>Xpts</em>[], <em class="property">const</em> TacsScalar <em>vars</em>[], <em class="property">const</em> TacsScalar <em>dvars</em>[], <em class="property">const</em> TacsScalar <em>ddvars</em>[], <em class="property">const</em> TacsScalar <em>dfdq</em>[], TacsScalar <em>dfdXpts</em>[]<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement23addPointQuantityXptSensEiid10TacsScalariA_dA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add the derivative of the point quantity w.r.t. the node locations</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elemIndex</span></code>: The index of the element </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">quantityType</span></code>: The integer indicating the pointwise quantity </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time</span></code>: The simulation time </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">scale</span></code>: The scalar factor applied to the derivative </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code>: The quadrature point index </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pt</span></code>: The quadrature point </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Xpts</span></code>: The element node locations </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vars</span></code>: The values of the element degrees of freedom </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvars</span></code>: The first time derivative of the element DOF </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ddvars</span></code>: The second time derivative of the element DOF </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvLen</span></code>: The length of the design array </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dfdu</span></code>: The derivative of the quantity w.r.t. state variables </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N11TACSElement13getOutputDataEi11ElementTypeiA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalariP10TacsScalar">
<span id="_CPPv3N11TACSElement13getOutputDataEi11ElementTypeiA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalariP10TacsScalar"></span><span id="_CPPv2N11TACSElement13getOutputDataEi11ElementTypeiA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalariP10TacsScalar"></span><span id="TACSElement::getOutputData__i.ElementType.i.TacsScalarCA.TacsScalarCA.TacsScalarCA.TacsScalarCA.i.TacsScalarP"></span><span class="target" id="class_t_a_c_s_element_1a27e0e950edfb5f2f1e414d4913152821"></span><em class="property">virtual</em> void <code class="sig-name descname">getOutputData</code><span class="sig-paren">(</span>int <em>elemIndex</em>, ElementType <em>etype</em>, int <em>write_flag</em>, <em class="property">const</em> TacsScalar <em>Xpts</em>[], <em class="property">const</em> TacsScalar <em>vars</em>[], <em class="property">const</em> TacsScalar <em>dvars</em>[], <em class="property">const</em> TacsScalar <em>ddvars</em>[], int <em>ld_data</em>, TacsScalar *<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N11TACSElement13getOutputDataEi11ElementTypeiA_K10TacsScalarA_K10TacsScalarA_K10TacsScalarA_K10TacsScalariP10TacsScalar" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compute the output data for visualization</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elemIndex</span></code>: The local element index </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">etype</span></code>: The type of element data to be output </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">write_flag</span></code>: The type of data to be output </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Xpts</span></code>: The element node locations </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vars</span></code>: The values of the element degrees of freedom </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvars</span></code>: The first time derivative of the element DOF </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ddvars</span></code>: The second time derivative of the element DOF </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ld_data</span></code>: The dimension of the data </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code>: The data to be created </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Example-CRM_Optimization.html" title="Example: CRM Optimization"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">TACS  documentation</a> &#187;</li> 
      </ul>
    </div>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>

  </body>
</html>