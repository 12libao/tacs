#ifndef TACS_GIBBS_VECTOR_H
#define TACS_GIBBS_VECTOR_H

/*
  Copyright (c) 2015-2016 Graeme Kennedy. All rights reserved
*/

/*
  The following class defines a Gibbs vector: A 3D vector in the
  global inertial reference frame.

  The components of this vector can be set as design variables that
  modify either initial conditions or the initial orientation of the
  bodies within a multibody system.  
*/
class TACSGibbsVector : public TACSObject {
 public:
  TACSGibbsVector( const TacsScalar _x[] );
  TACSGibbsVector( const TacsScalar _x[], const int _xDV[] );
  ~TACSGibbsVector(){}

  void getVector( const TacsScalar **_x );
  void setDesignVars( const TacsScalar *dvs, int numDVs );
  void getDesignVars( TacsScalar *dvs, int numDVs );
  void addPointAdjResProduct( TacsScalar fdvSens[], int numDVs,
                              TacsScalar scale,
                              const TacsScalar psi[] );
 private:
  TacsScalar x[3];
  int xDV[3];
};

/*
  A vector class for the multibody dynamics code. 

  These vectors are global objects that exist in the global reference
  frame. The purpose of this object is to provide an easier input to
  the initial set up of dynamics problems. All input is specified in a
  global reference frame (except for body-fixed frame inertial
  properties.)

  Reference points within the body-fixed frames are generated by each
  body at the initial point for analysis.

  input:
  x:    the 3-space coordinate of the point
  
  Note: The design variable numbers are initialized to -1
*/
inline TACSGibbsVector::TACSGibbsVector( const TacsScalar _x[] ){
  x[0] = _x[0];
  x[1] = _x[1];
  x[2] = _x[2];
  xDV[0] = xDV[1] = xDV[2] = -1;
}

/*
  Create an point in the inertial reference frame

  input:
  x:    the coordinate of the point
  xDV:  the design variable numbers of the point
*/
inline TACSGibbsVector::TACSGibbsVector( const TacsScalar _x[], 
                                         const int _xDV[] ){
  x[0] = _x[0];
  x[1] = _x[1];
  x[2] = _x[2];
  xDV[0] = _xDV[0];
  xDV[1] = _xDV[1];
  xDV[2] = _xDV[2];
}

/*
  Retrieve the coordinates of the point
*/
inline void TACSGibbsVector::getVector( const TacsScalar **_x ){ 
  *_x = x;
}
 
/*
  Set the design variable values from the input vector into this object

  input:
  dvs:    the design variable values
  numDVs: the number of design variable values in the array
*/
inline void TACSGibbsVector::setDesignVars( const TacsScalar *dvs, int numDVs ){
  if (xDV[0] >= 0 && xDV[0] < numDVs){ x[0] = dvs[xDV[0]]; }
  if (xDV[1] >= 0 && xDV[1] < numDVs){ x[1] = dvs[xDV[1]]; }
  if (xDV[2] >= 0 && xDV[2] < numDVs){ x[2] = dvs[xDV[2]]; }
}

/*
  Retrieve the design variable values from the object
  
  input:
  numDVs:  the number of design variable values in the array

  output:
  dvs:     the design variable values retrieved from the object
*/
inline void TACSGibbsVector::getDesignVars( TacsScalar *dvs, int numDVs ){
  if (xDV[0] >= 0 && xDV[0] < numDVs){ dvs[xDV[0]] = x[0]; }
  if (xDV[1] >= 0 && xDV[1] < numDVs){ dvs[xDV[1]] = x[1]; }
  if (xDV[2] >= 0 && xDV[2] < numDVs){ dvs[xDV[2]] = x[2]; }
}

/*
  Add the derivative associated with the point locations to the vector.

  input:
  numDVs:  the number of design variables
  scale:   the sensitivity is multiplied by this scalar
  psi:     the adjoint vector
  
  input/output:
  fdvSens: the array of derivatives
*/
inline void TACSGibbsVector::addPointAdjResProduct( TacsScalar fdvSens[], 
                                                    int numDVs,
                                                    TacsScalar scale,
                                                    const TacsScalar psi[] ){
  if (xDV[0] >= 0 && xDV[0] < numDVs){ fdvSens[xDV[0]] += scale*psi[0]; }
  if (xDV[1] >= 0 && xDV[1] < numDVs){ fdvSens[xDV[1]] += scale*psi[1]; }
  if (xDV[2] >= 0 && xDV[2] < numDVs){ fdvSens[xDV[2]] += scale*psi[2]; }
}

#endif // TACS_GIBBS_VECTOR_H
